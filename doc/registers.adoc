[cols="1s,1,1,1"]
|===
| register
^| lan966x
^| lan969x
^| sparx5

| <<ADDRMAP0>>
^| yes
^| yes
^| yes

| <<ADDRMAP1>>
^| yes
^| yes
^| yes

| <<ADDRMAP2>>
^| yes
^| yes
^| yes

| <<ADDRMAP3>>
^| yes
^| yes
^| yes

| <<ADDRMAP4>>
^| yes
^| yes
^| yes

| <<ADDRMAP5>>
^| yes
^| yes
^| yes

| <<ADDRMAP6>>
^| yes
^| yes
^| yes

| <<ADDRMAP7>>
^s| no
^| yes
^| yes

| <<ADDRMAP8>>
^s| no
^| yes
^| yes

| <<CRCPARCTL1>>
^s| no
^| yes
^| yes

| <<DBICTL>>
^s| no
^| yes
^| yes

| <<DCR>>
^| yes
^| yes
^| yes

| <<DFIMISC>>
^| yes
^| yes
^| yes

| <<DFITMG0>>
^| yes
^| yes
^| yes

| <<DFITMG1>>
^| yes
^| yes
^| yes

| <<DFIUPD0>>
^| yes
^| yes
^| yes

| <<DFIUPD1>>
^| yes
^| yes
^| yes

| <<DRAMTMG0>>
^| yes
^| yes
^| yes

| <<DRAMTMG1>>
^| yes
^| yes
^| yes

| <<DRAMTMG12>>
^s| no
^| yes
^| yes

| <<DRAMTMG2>>
^| yes
^| yes
^| yes

| <<DRAMTMG3>>
^| yes
^| yes
^| yes

| <<DRAMTMG4>>
^| yes
^| yes
^| yes

| <<DRAMTMG5>>
^| yes
^| yes
^| yes

| <<DRAMTMG8>>
^| yes
^| yes
^| yes

| <<DRAMTMG9>>
^s| no
^| yes
^| yes

| <<DSGCR>>
^| yes
^| yes
^| yes

| <<DTCR>>
^| yes
^s| no
^s| no

| <<DTCR0>>
^s| no
^| yes
^| yes

| <<DTCR1>>
^s| no
^| yes
^| yes

| <<DTPR0>>
^| yes
^| yes
^| yes

| <<DTPR1>>
^| yes
^| yes
^| yes

| <<DTPR2>>
^| yes
^| yes
^| yes

| <<DTPR3>>
^s| no
^| yes
^| yes

| <<DTPR4>>
^s| no
^| yes
^| yes

| <<DTPR5>>
^s| no
^| yes
^| yes

| <<DXCCR>>
^| yes
^| yes
^| yes

| <<ECCCFG0>>
^| yes
^| yes
^| yes

| <<INIT0>>
^| yes
^| yes
^| yes

| <<INIT1>>
^| yes
^| yes
^| yes

| <<INIT3>>
^| yes
^| yes
^| yes

| <<INIT4>>
^| yes
^| yes
^| yes

| <<INIT5>>
^| yes
^| yes
^| yes

| <<INIT6>>
^s| no
^| yes
^| yes

| <<INIT7>>
^s| no
^| yes
^| yes

| <<MSTR>>
^| yes
^| yes
^| yes

| <<ODTCFG>>
^| yes
^| yes
^| yes

| <<PCCFG>>
^| yes
^| yes
^| yes

| <<PGCR2>>
^| yes
^| yes
^| yes

| <<PTR0>>
^| yes
^| yes
^| yes

| <<PTR1>>
^| yes
^| yes
^| yes

| <<PTR2>>
^| yes
^| yes
^| yes

| <<PTR3>>
^| yes
^| yes
^| yes

| <<PTR4>>
^| yes
^| yes
^| yes

| <<PWRCTL>>
^| yes
^| yes
^| yes

| <<RFSHCTL0>>
^| yes
^| yes
^| yes

| <<RFSHCTL3>>
^| yes
^| yes
^| yes

| <<RFSHTMG>>
^| yes
^| yes
^| yes

| <<SBRCTL>>
^s| no
^s| no
^| yes

| <<SCHCR1>>
^s| no
^| yes
^| yes

| <<ZQ0CR0>>
^| yes
^s| no
^s| no

| <<ZQ0CR1>>
^| yes
^s| no
^s| no

| <<ZQ0PR>>
^s| no
^| yes
^| yes

| <<ZQ1CR0>>
^| yes
^s| no
^s| no

| <<ZQ1CR1>>
^| yes
^s| no
^s| no

| <<ZQ1PR>>
^s| no
^| yes
^| yes

| <<ZQ2PR>>
^s| no
^| yes
^| yes

| <<ZQCR>>
^s| no
^| yes
^| yes


|===

Register fields below are given including start and end bits. The
value following in parenthesis is the default value.

=== ADDRMAP0

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_CS_BIT0
^| bit 4..0 (0)


^| bit 4..0 (0)


^| bit 4..0 (0)


|===

=== ADDRMAP1

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_BANK_B2
^| bit 5..16 (0)


^| bit 5..16 (0)


^| bit 5..16 (0)

| ADDRMAP_BANK_B1
^| bit 5..8 (0)


^| bit 5..8 (0)


^| bit 5..8 (0)

| ADDRMAP_BANK_B0
^| bit 5..0 (0)


^| bit 5..0 (0)


^| bit 5..0 (0)


|===

=== ADDRMAP2

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_COL_B5
^| bit 3..24 (0)


^| bit 3..24 (0)


^| bit 3..24 (0)

| ADDRMAP_COL_B4
^| bit 3..16 (0)


^| bit 3..16 (0)


^| bit 3..16 (0)

| ADDRMAP_COL_B3
^| bit 4..8 (0)


^| bit 4..8 (0)


^| bit 3..8 (0)

| ADDRMAP_COL_B2
^| bit 3..0 (0)


^| bit 3..0 (0)


^| bit 3..0 (0)


|===

=== ADDRMAP3

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_COL_B9
^| bit 4..24 (0)


^| bit 4..24 (0)


^| bit 4..24 (0)

| ADDRMAP_COL_B8
^| bit 4..16 (0)


^| bit 4..16 (0)


^| bit 4..16 (0)

| ADDRMAP_COL_B7
^| bit 4..8 (0)


^| bit 4..8 (0)


^| bit 4..8 (0)

| ADDRMAP_COL_B6
^| bit 4..0 (0)


^| bit 4..0 (0)


^| bit 3..0 (0)


|===

=== ADDRMAP4

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_COL_B11
^| bit 4..8 (0)


^| bit 4..8 (0)


^| bit 4..8 (0)

| ADDRMAP_COL_B10
^| bit 4..0 (0)


^| bit 4..0 (0)


^| bit 4..0 (0)


|===

=== ADDRMAP5

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_ROW_B11
^| bit 3..24 (0)


^| bit 3..24 (0)


^| bit 3..24 (0)

| ADDRMAP_ROW_B2_10
^| bit 3..16 (0)


^| bit 3..16 (0)


^| bit 3..16 (0)

| ADDRMAP_ROW_B1
^| bit 3..8 (0)


^| bit 3..8 (0)


^| bit 3..8 (0)

| ADDRMAP_ROW_B0
^| bit 3..0 (0)


^| bit 3..0 (0)


^| bit 3..0 (0)


|===

=== ADDRMAP6

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_ROW_B15
^| bit 3..24 (0)


^| bit 3..24 (0)


^| bit 3..24 (0)

| ADDRMAP_ROW_B14
^| bit 3..16 (0)


^| bit 3..16 (0)


^| bit 3..16 (0)

| ADDRMAP_ROW_B13
^| bit 3..8 (0)


^| bit 3..8 (0)


^| bit 3..8 (0)

| ADDRMAP_ROW_B12
^| bit 3..0 (0)


^| bit 3..0 (0)


^| bit 3..0 (0)

| LPDDR3_6GB_12GB
^| 

^| 

^| bit 31 (0)


|===

=== ADDRMAP7

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_ROW_B16
^| 

^| bit 3..0 (0)


^| bit 3..0 (0)

| ADDRMAP_ROW_B17
^| 

^| bit 3..8 (0)


^| bit 3..8 (0)


|===

=== ADDRMAP8

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_BG_B0
^| 

^| bit 5..0 (0)


^| bit 5..0 (0)

| ADDRMAP_BG_B1
^| 

^| bit 5..8 (0)


^| bit 5..8 (0)


|===

=== CRCPARCTL1

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| PARITY_ENABLE
^| 

^| bit 0 (0)


^| bit 0 (0)

| CRC_ENABLE
^| 

^| bit 4 (0)


^| bit 4 (0)

| CRC_INC_DM
^| 

^| bit 7 (0)


^| bit 7 (0)

| CAPARITY_DISABLE_BEFORE_SR
^| 

^| bit 12 (1)


^| bit 12 (1)


|===

=== DBICTL

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DM_EN
^| 

^| bit 0 (1)


^| bit 0 (1)

| WR_DBI_EN
^| 

^| bit 1 (0)


^| bit 1 (0)

| RD_DBI_EN
^| 

^| bit 2 (0)


^| bit 2 (0)


|===

=== DCR

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| UDIMM
^| bit 29 (0)


^| bit 29 (0)


^| bit 29 (0)

| DDR2T
^| bit 28 (0)


^| bit 28 (0)


^| bit 28 (0)

| NOSRA
^| bit 27 (0)


^| bit 27 (0)


^| bit 27 (0)

| BYTEMASK
^| bit 7..10 (1)


^| bit 7..10 (1)


^| bit 7..10 (1)

| MPRDQ
^| bit 7 (0)


^| bit 7 (0)


^| bit 7 (0)

| PDQ
^| bit 2..4 (0)


^| bit 2..4 (0)


^| bit 2..4 (0)

| DDR8BNK
^| bit 3 (1)


^| bit 3 (1)


^| bit 3 (1)

| DDRMD
^| bit 2..0 (3)


^| bit 2..0 (3)


^| bit 2..0 (3)

| DDRTYPE
^| 

^| bit 1..8 (0)


^| bit 1..8 (0)

| RESERVED_26_18
^| 

^| bit 8..18 (0)


^| bit 8..18 (0)

| UBG
^| 

^| bit 30 (0)


^| bit 30 (0)

| RESERVED_31
^| 

^| bit 31 (0)


^| bit 31 (0)


|===

=== DFIMISC

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DFI_FREQUENCY
^| bit 4..8 (0)


^| bit 4..8 (0)


^| bit 4..8 (0)

| DFI_INIT_START
^| bit 5 (0)


^| bit 5 (0)


^| bit 5 (0)

| CTL_IDLE_EN
^| bit 4 (0)


^| bit 4 (0)


^| bit 4 (0)

| DFI_INIT_COMPLETE_EN
^| bit 0 (1)


^| bit 0 (1)


^| bit 0 (1)

| PHY_DBI_MODE
^| 

^| bit 1 (0)


^| bit 1 (0)

| DIS_DYN_ADR_TRI
^| 

^| bit 6 (1)


^| 

|===

=== DFITMG0

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DFI_T_CTRL_DELAY
^| bit 4..24 (7)


^| bit 4..24 (7)


^| bit 4..24 (7)

| DFI_RDDATA_USE_DFI_PHY_CLK
^| bit 23 (0)


^| bit 23 (0)


^| bit 23 (0)

| DFI_T_RDDATA_EN
^| bit 6..16 (2)


^| bit 6..16 (2)


^| bit 6..16 (2)

| DFI_WRDATA_USE_DFI_PHY_CLK
^| bit 15 (0)


^| bit 15 (0)


^| bit 15 (0)

| DFI_TPHY_WRDATA
^| bit 5..8 (0)


^| bit 5..8 (0)


^| bit 5..8 (0)

| DFI_TPHY_WRLAT
^| bit 5..0 (2)


^| bit 5..0 (2)


^| bit 5..0 (2)


|===

=== DFITMG1

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DFI_T_PARIN_LAT
^| bit 1..24 (0)


^| bit 1..24 (0)


^| bit 1..24 (0)

| DFI_T_WRDATA_DELAY
^| bit 4..16 (0)


^| bit 4..16 (0)


^| bit 4..16 (0)

| DFI_T_DRAM_CLK_DISABLE
^| bit 4..8 (4)


^| bit 4..8 (4)


^| bit 4..8 (4)

| DFI_T_DRAM_CLK_ENABLE
^| bit 4..0 (4)


^| bit 4..0 (4)


^| bit 4..0 (4)

| DFI_T_CMD_LAT
^| 

^| bit 3..28 (0)


^| bit 3..28 (0)


|===

=== DFIUPD0

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DIS_AUTO_CTRLUPD
^| bit 31 (0)


^| bit 31 (0)


^| bit 31 (0)

| DIS_AUTO_CTRLUPD_SRX
^| bit 30 (0)


^| bit 30 (0)


^| bit 30 (0)

| CTRLUPD_PRE_SRX
^| bit 29 (0)


^| bit 29 (0)


^| bit 29 (0)

| DFI_T_CTRLUP_MAX
^| bit 9..16 (64)


^| bit 9..16 (64)


^| bit 9..16 (64)

| DFI_T_CTRLUP_MIN
^| bit 9..0 (3)


^| bit 9..0 (3)


^| bit 9..0 (3)


|===

=== DFIUPD1

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DFI_T_CTRLUPD_INTERVAL_MIN_X1024
^| bit 7..16 (1)


^| bit 7..16 (1)


^| bit 7..16 (1)

| DFI_T_CTRLUPD_INTERVAL_MAX_X1024
^| bit 7..0 (1)


^| bit 7..0 (1)


^| bit 7..0 (1)


|===

=== DRAMTMG0

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| WR2PRE
^| bit 6..24 (15)


^| bit 6..24 (15)


^| bit 6..24 (15)

| T_FAW
^| bit 5..16 (16)


^| bit 5..16 (16)


^| bit 5..16 (16)

| T_RAS_MAX
^| bit 6..8 (27)


^| bit 6..8 (27)


^| bit 6..8 (27)

| T_RAS_MIN
^| bit 5..0 (15)


^| bit 5..0 (15)


^| bit 5..0 (15)


|===

=== DRAMTMG1

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| T_XP
^| bit 4..16 (8)


^| bit 4..16 (8)


^| bit 4..16 (8)

| RD2PRE
^| bit 5..8 (4)


^| bit 5..8 (4)


^| bit 5..8 (4)

| T_RC
^| bit 6..0 (20)


^| bit 6..0 (20)


^| bit 6..0 (20)


|===

=== DRAMTMG12

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| T_MRD_PDA
^| 

^| bit 4..0 (16)


^| bit 4..0 (16)

| T_WR_MPR
^| 

^| bit 5..24 (26)


^| 

|===

=== DRAMTMG2

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| RD2WR
^| bit 5..8 (6)


^| bit 5..8 (6)


^| bit 5..8 (6)

| WR2RD
^| bit 5..0 (13)


^| bit 5..0 (13)


^| bit 5..0 (13)

| READ_LATENCY
^| 

^| bit 5..16 (5)


^| bit 5..16 (5)

| WRITE_LATENCY
^| 

^| bit 5..24 (3)


^| bit 5..24 (3)


|===

=== DRAMTMG3

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| T_MRD
^| bit 5..12 (4)


^| bit 5..12 (4)


^| bit 5..12 (4)

| T_MOD
^| bit 9..0 (12)


^| bit 9..0 (12)


^| bit 9..0 (12)

| T_MRW
^| 

^| 

^| bit 9..20 (5)


|===

=== DRAMTMG4

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| T_RCD
^| bit 4..24 (5)


^| bit 4..24 (5)


^| bit 4..24 (5)

| T_CCD
^| bit 3..16 (4)


^| bit 3..16 (4)


^| bit 3..16 (4)

| T_RRD
^| bit 3..8 (4)


^| bit 3..8 (4)


^| bit 3..8 (4)

| T_RP
^| bit 4..0 (5)


^| bit 4..0 (5)


^| bit 4..0 (5)


|===

=== DRAMTMG5

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| T_CKSRX
^| bit 3..24 (5)


^| bit 3..24 (5)


^| bit 3..24 (5)

| T_CKSRE
^| bit 6..16 (5)


^| bit 7..16 (5)


^| bit 3..16 (5)

| T_CKESR
^| bit 5..8 (4)


^| bit 7..8 (4)


^| bit 5..8 (4)

| T_CKE
^| bit 4..0 (3)


^| bit 4..0 (3)


^| bit 4..0 (3)


|===

=== DRAMTMG8

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| T_XS_DLL_X32
^| bit 6..8 (68)


^| bit 6..8 (68)


^| bit 6..8 (68)

| T_XS_X32
^| bit 6..0 (5)


^| bit 6..0 (5)


^| bit 6..0 (5)

| T_XS_ABORT_X32
^| 

^| bit 6..16 (3)


^| bit 6..16 (3)

| T_XS_FAST_X32
^| 

^| bit 6..24 (3)


^| bit 6..24 (3)


|===

=== DRAMTMG9

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| WR2RD_S
^| 

^| bit 5..0 (13)


^| bit 5..0 (13)

| T_RRD_S
^| 

^| bit 3..8 (4)


^| bit 3..8 (4)

| T_CCD_S
^| 

^| bit 2..16 (4)


^| bit 2..16 (4)

| DDR4_WR_PREAMBLE
^| 

^| bit 30 (0)


^| bit 30 (0)


|===

=== DSGCR

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| CKEOE
^| bit 31 (1)


^| 

^| 
| RSTOE
^| bit 30 (1)


^| bit 21 (1)


^| bit 21 (1)

| ODTOE
^| bit 29 (1)


^| 

^| 
| CKOE
^| bit 28 (1)


^| 

^| 
| ODTPDD
^| bit 3..24 (0)


^| 

^| 
| CKEPDD
^| bit 3..20 (0)


^| 

^| 
| SDRMODE
^| bit 19 (0)


^| bit 1..19 (0)


^| bit 1..19 (0)

| RRMODE
^| bit 18 (0)


^| 

^| 
| ATOAE
^| bit 17 (0)


^| bit 17 (0)


^| bit 17 (0)

| DTOOE
^| bit 16 (0)


^| bit 16 (0)


^| bit 16 (0)

| DTOIOM
^| bit 15 (0)


^| bit 15 (0)


^| bit 15 (0)

| DTOPDR
^| bit 14 (1)


^| bit 14 (1)


^| bit 14 (1)

| DTOPDD
^| bit 13 (1)


^| 

^| 
| DTOODT
^| bit 12 (0)


^| bit 12 (0)


^| bit 12 (0)

| PUAD
^| bit 3..8 (4)


^| bit 3..8 (0)


^| bit 3..8 (0)

| BRRMODE
^| bit 7 (0)


^| 

^| 
| DQSGX
^| bit 6 (0)


^| bit 1..6 (0)


^| bit 1..6 (0)

| CUAEN
^| bit 5 (0)


^| bit 5 (0)


^| bit 5 (0)

| LPPLLPD
^| bit 4 (1)


^| bit 4 (1)


^| bit 4 (1)

| LPIOPD
^| bit 3 (1)


^| bit 3 (1)


^| bit 3 (1)

| ZUEN
^| bit 2 (1)


^| 

^| 
| BDISEN
^| bit 1 (1)


^| bit 1 (1)


^| bit 1 (1)

| PUREN
^| bit 0 (1)


^| bit 0 (1)


^| bit 0 (1)

| CTLZUEN
^| 

^| bit 2 (0)


^| bit 2 (0)

| RESERVED_13
^| 

^| bit 13 (0)


^| bit 13 (0)

| WRRMODE
^| 

^| bit 18 (1)


^| bit 18 (1)

| RRRMODE
^| 

^| bit 22 (1)


^| bit 22 (1)

| PHYZUEN
^| 

^| bit 23 (0)


^| bit 23 (0)

| LPACIOPD
^| 

^| bit 24 (0)


^| 
| RESERVED_31_25
^| 

^| bit 6..25 (0)


^| 
| RESERVED_31_24
^| 

^| 

^| bit 7..24 (0)


|===

=== DTCR

Applies to: lan966x



[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| RFSHDT
^| bit 3..28 (9)


^| 

^| 
| RANKEN
^| bit 3..24 (15)


^| 

^| 
| DTEXD
^| bit 22 (0)


^| 

^| 
| DTDSTP
^| bit 21 (0)


^| 

^| 
| DTDEN
^| bit 20 (0)


^| 

^| 
| DTDBS
^| bit 3..16 (0)


^| 

^| 
| DTWDQMO
^| bit 14 (0)


^| 

^| 
| DTBDC
^| bit 13 (1)


^| 

^| 
| DTWBDDM
^| bit 12 (1)


^| 

^| 
| DTWDQM
^| bit 3..8 (5)


^| 

^| 
| DTCMPD
^| bit 7 (1)


^| 

^| 
| DTMPR
^| bit 6 (0)


^| 

^| 
| DTRANK
^| bit 1..4 (0)


^| 

^| 
| DTRPTN
^| bit 3..0 (7)


^| 

^| 

|===

=== DTCR0

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DTRPTN
^| 

^| bit 3..0 (7)


^| bit 3..0 (7)

| RESERVED_5_4
^| 

^| bit 1..4 (0)


^| bit 1..4 (0)

| DTMPR
^| 

^| bit 6 (0)


^| bit 6 (0)

| DTCMPD
^| 

^| bit 7 (1)


^| bit 7 (1)

| RESERVED_10_8
^| 

^| bit 2..8 (0)


^| bit 2..8 (0)

| DTDBS4
^| 

^| bit 11 (0)


^| bit 11 (0)

| DTWBDDM
^| 

^| bit 12 (1)


^| bit 12 (1)

| DTBDC
^| 

^| bit 13 (1)


^| bit 13 (1)

| DTRDBITR
^| 

^| bit 1..14 (2)


^| bit 1..14 (2)

| DTDBS
^| 

^| bit 3..16 (0)


^| bit 3..16 (0)

| DTDEN
^| 

^| bit 20 (0)


^| bit 20 (0)

| DTDSTP
^| 

^| bit 21 (0)


^| bit 21 (0)

| DTEXD
^| 

^| bit 22 (0)


^| bit 22 (0)

| RESERVED_23
^| 

^| bit 23 (0)


^| 
| DTDRS
^| 

^| bit 1..24 (0)


^| bit 1..24 (0)

| RESERVED_27_26
^| 

^| bit 1..26 (0)


^| bit 1..26 (0)

| RFSHDT
^| 

^| bit 3..28 (8)


^| bit 3..28 (8)

| DTEXG
^| 

^| 

^| bit 23 (0)


|===

=== DTCR1

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| BSTEN
^| 

^| bit 0 (1)


^| bit 0 (1)

| RDLVLEN
^| 

^| bit 1 (1)


^| bit 1 (1)

| RDPRMBL_TRN
^| 

^| bit 2 (1)


^| bit 2 (1)

| RESERVED_3
^| 

^| bit 3 (0)


^| bit 3 (0)

| RDLVLGS
^| 

^| bit 2..4 (3)


^| bit 2..4 (3)

| RESERVED_7
^| 

^| bit 7 (0)


^| bit 7 (0)

| RDLVLGDIFF
^| 

^| bit 2..8 (2)


^| bit 2..8 (2)

| WLVLDPRD
^| 

^| bit 11 (1)


^| 
| DTRANK
^| 

^| bit 1..12 (0)


^| bit 1..12 (0)

| RESERVED_15_14
^| 

^| bit 1..14 (0)


^| bit 1..14 (0)

| RANKEN
^| 

^| bit 1..16 (3)


^| bit 1..16 (3)

| RANKEN_RSVD
^| 

^| bit 13..18 (0)


^| bit 13..18 (0)

| RESERVED_11
^| 

^| 

^| bit 11 (0)


|===

=== DTPR0

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TRC
^| bit 5..26 (50)


^| 

^| 
| TRRD
^| bit 3..22 (7)


^| bit 5..24 (7)


^| bit 5..24 (7)

| TRAS
^| bit 5..16 (36)


^| bit 6..16 (36)


^| bit 6..16 (36)

| TRCD
^| bit 3..12 (14)


^| 

^| 
| TRP
^| bit 3..8 (14)


^| bit 6..8 (14)


^| bit 6..8 (14)

| TWTR
^| bit 3..4 (8)


^| 

^| 
| TRTP
^| bit 3..0 (8)


^| bit 3..0 (8)


^| bit 3..0 (8)

| RESERVED_7_4
^| 

^| bit 3..4 (0)


^| bit 3..4 (0)

| RESERVED_15
^| 

^| bit 15 (0)


^| bit 15 (0)

| RESERVED_23
^| 

^| bit 23 (0)


^| bit 23 (0)

| RESERVED_31_30
^| 

^| bit 1..30 (0)


^| bit 1..30 (0)


|===

=== DTPR1

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TAON_OFF_D
^| bit 1..30 (0)


^| 

^| 
| TWLO
^| bit 3..26 (8)


^| 

^| 
| TWLMRD
^| bit 5..20 (40)


^| bit 5..24 (40)


^| bit 5..24 (40)

| TRFC
^| bit 8..11 (374)


^| 

^| 
| TFAW
^| bit 5..5 (38)


^| bit 7..16 (38)


^| bit 7..16 (38)

| TMOD
^| bit 2..2 (4)


^| bit 2..8 (4)


^| bit 2..8 (4)

| TMRD
^| bit 1..0 (2)


^| bit 4..0 (6)


^| bit 4..0 (6)

| RESERVED_7_5
^| 

^| bit 2..5 (0)


^| bit 2..5 (0)

| RESERVED_15_11
^| 

^| bit 4..11 (0)


^| bit 4..11 (0)

| RESERVED_31_30
^| 

^| bit 1..30 (0)


^| bit 1..30 (0)


|===

=== DTPR2

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TCCD
^| bit 31 (0)


^| 

^| 
| TRTW
^| bit 30 (0)


^| bit 28 (0)


^| bit 28 (0)

| TRTODT
^| bit 29 (0)


^| bit 24 (0)


^| bit 24 (0)

| TDLLK
^| bit 9..19 (512)


^| 

^| 
| TCKE
^| bit 3..15 (6)


^| bit 3..16 (6)


^| bit 3..16 (6)

| TXP
^| bit 4..10 (26)


^| 

^| 
| TXS
^| bit 9..0 (512)


^| bit 9..0 (512)


^| bit 9..0 (512)

| RESERVED_15_10
^| 

^| bit 5..10 (0)


^| bit 5..10 (0)

| RESERVED_23_20
^| 

^| bit 3..20 (0)


^| bit 3..20 (0)

| RESERVED_27_25
^| 

^| bit 2..25 (0)


^| bit 2..25 (0)

| RESERVED_31_29
^| 

^| bit 2..29 (0)


^| bit 2..29 (0)


|===

=== DTPR3

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TDQSCK
^| 

^| bit 2..0 (1)


^| bit 2..0 (1)

| RESERVED_7_3
^| 

^| bit 4..3 (0)


^| bit 4..3 (0)

| TDQSCKMAX
^| 

^| bit 2..8 (1)


^| bit 2..8 (1)

| RESERVED_15_11
^| 

^| bit 4..11 (0)


^| bit 4..11 (0)

| TDLLK
^| 

^| bit 9..16 (384)


^| bit 9..16 (384)

| TCCD
^| 

^| bit 2..26 (0)


^| bit 2..26 (0)

| TOFDX
^| 

^| bit 2..29 (0)


^| bit 2..29 (0)


|===

=== DTPR4

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TXP
^| 

^| bit 4..0 (26)


^| bit 4..0 (26)

| RESERVED_7_5
^| 

^| bit 2..5 (0)


^| bit 2..5 (0)

| TWLO
^| 

^| bit 3..8 (8)


^| bit 3..8 (8)

| RESERVED_15_12
^| 

^| bit 3..12 (0)


^| bit 3..12 (0)

| TRFC
^| 

^| bit 9..16 (374)


^| bit 9..16 (374)

| RESERVED_27_26
^| 

^| bit 1..26 (0)


^| bit 1..26 (0)

| TAOND_TAOFD
^| 

^| bit 1..28 (0)


^| bit 1..28 (0)

| RESERVED_31_30
^| 

^| bit 1..30 (0)


^| bit 1..30 (0)


|===

=== DTPR5

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TWTR
^| 

^| bit 4..0 (8)


^| bit 4..0 (8)

| RESERVED_7_5
^| 

^| bit 2..5 (0)


^| bit 2..5 (0)

| TRCD
^| 

^| bit 6..8 (14)


^| bit 6..8 (14)

| RESERVED_15
^| 

^| bit 15 (0)


^| bit 15 (0)

| TRC
^| 

^| bit 7..16 (50)


^| bit 7..16 (50)

| RESERVED_31_24
^| 

^| bit 7..24 (0)


^| bit 7..24 (0)


|===

=== DXCCR

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DDPDRCDO
^| bit 3..28 (4)


^| 

^| 
| DDPDDCDO
^| bit 3..24 (4)


^| 

^| 
| DYNDXPDR
^| bit 23 (0)


^| 

^| 
| DYNDXPDD
^| bit 22 (0)


^| 

^| 
| UDQIOM
^| bit 21 (0)


^| bit 21 (0)


^| bit 21 (0)

| UDQPDR
^| bit 20 (1)


^| 

^| 
| UDQPDD
^| bit 19 (1)


^| 

^| 
| UDQODT
^| bit 18 (0)


^| 

^| 
| MSBUDQ
^| bit 2..15 (0)


^| bit 2..15 (0)


^| bit 2..15 (0)

| DQSNRES
^| bit 3..9 (12)


^| bit 3..9 (12)


^| bit 3..9 (12)

| DQSRES
^| bit 3..5 (4)


^| bit 3..5 (4)


^| bit 3..5 (4)

| DXPDR
^| bit 4 (0)


^| 

^| 
| DXPDD
^| bit 3 (0)


^| 

^| 
| MDLEN
^| bit 2 (1)


^| bit 2 (1)


^| bit 2 (1)

| DXIOM
^| bit 1 (0)


^| bit 1 (0)


^| bit 1 (0)

| DXODT
^| bit 0 (0)


^| bit 0 (0)


^| bit 0 (0)

| DQSGLB
^| 

^| bit 1..3 (0)


^| bit 1..3 (0)

| DXSR
^| 

^| bit 1..13 (0)


^| bit 1..13 (0)

| RESERVED_19_18
^| 

^| bit 1..18 (0)


^| 
| QSCNTENCTL
^| 

^| bit 20 (0)


^| 
| QSCNTEN
^| 

^| bit 22 (1)


^| bit 22 (1)

| DXDCCBYP
^| 

^| bit 23 (1)


^| bit 23 (1)

| RESERVED_28_24
^| 

^| bit 4..24 (0)


^| bit 4..24 (0)

| RKLOOP
^| 

^| bit 29 (1)


^| bit 29 (1)

| X4DQSMD
^| 

^| bit 30 (0)


^| bit 30 (0)

| X4MODE
^| 

^| bit 31 (0)


^| bit 31 (0)

| RESERVED_20_18
^| 

^| 

^| bit 2..18 (0)


|===

=== ECCCFG0

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ECC_REGION_MAP_GRANU
^| bit 1..30 (0)


^| bit 1..30 (0)


^| 
| ECC_REGION_MAP_OTHER
^| bit 29 (0)


^| bit 29 (0)


^| 
| ECC_AP_ERR_THRESHOLD
^| bit 24 (0)


^| bit 24 (0)


^| 
| BLK_CHANNEL_IDLE_TIME_X32
^| bit 5..16 (63)


^| bit 5..16 (63)


^| 
| ECC_REGION_MAP
^| bit 6..8 (127)


^| bit 6..8 (127)


^| 
| ECC_REGION_REMAP_EN
^| bit 7 (0)


^| bit 7 (0)


^| 
| ECC_AP_EN
^| bit 6 (1)


^| bit 6 (1)


^| 
| DIS_SCRUB
^| bit 4 (0)


^| bit 4 (0)


^| bit 4 (0)

| ECC_MODE
^| bit 2..0 (0)


^| bit 2..0 (0)


^| bit 2..0 (0)


|===

=== INIT0

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| SKIP_DRAM_INIT
^| bit 1..30 (0)


^| bit 1..30 (0)


^| bit 1..30 (0)

| POST_CKE_X1024
^| bit 9..16 (2)


^| bit 9..16 (2)


^| bit 9..16 (2)

| PRE_CKE_X1024
^| bit 11..0 (78)


^| bit 11..0 (78)


^| bit 11..0 (78)


|===

=== INIT1

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DRAM_RSTN_X1024
^| bit 8..16 (0)


^| bit 8..16 (0)


^| bit 8..16 (0)

| PRE_OCD_X32
^| bit 3..0 (0)


^| bit 3..0 (0)


^| bit 3..0 (0)


|===

=== INIT3

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| MR
^| bit 15..16 (0)


^| bit 15..16 (0)


^| bit 15..16 (0)

| EMR
^| bit 15..0 (1296)


^| bit 15..0 (1296)


^| bit 15..0 (1296)


|===

=== INIT4

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| EMR2
^| bit 15..16 (0)


^| bit 15..16 (0)


^| bit 15..16 (0)

| EMR3
^| bit 15..0 (0)


^| bit 15..0 (0)


^| bit 15..0 (0)


|===

=== INIT5

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DEV_ZQINIT_X32
^| bit 7..16 (16)


^| bit 7..16 (16)


^| bit 7..16 (16)

| MAX_AUTO_INIT_X1024
^| 

^| 

^| bit 9..0 (4)


|===

=== INIT6

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| MR5
^| 

^| bit 15..0 (0)


^| bit 15..0 (0)

| MR4
^| 

^| bit 15..16 (0)


^| bit 15..16 (0)


|===

=== INIT7

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| MR6
^| 

^| bit 15..0 (0)


^| bit 15..0 (0)


|===

=== MSTR

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ACTIVE_RANKS
^| bit 1..24 (3)


^| bit 1..24 (3)


^| bit 1..24 (3)

| BURST_RDWR
^| bit 3..16 (4)


^| bit 3..16 (4)


^| bit 3..16 (4)

| DLL_OFF_MODE
^| bit 15 (0)


^| bit 15 (0)


^| bit 15 (0)

| DATA_BUS_WIDTH
^| bit 1..12 (0)


^| bit 1..12 (0)


^| bit 1..12 (0)

| EN_2T_TIMING_MODE
^| bit 10 (0)


^| bit 10 (0)


^| bit 10 (0)

| BURSTCHOP
^| bit 9 (0)


^| bit 9 (0)


^| bit 9 (0)

| DDR3
^| bit 0 (1)


^| bit 0 (1)


^| bit 0 (1)

| DDR4
^| 

^| bit 4 (0)


^| bit 4 (0)

| GEARDOWN_MODE
^| 

^| bit 11 (0)


^| bit 11 (0)

| DEVICE_CONFIG
^| 

^| bit 1..30 (0)


^| bit 1..30 (0)

| LPDDR2
^| 

^| 

^| bit 2 (0)

| LPDDR3
^| 

^| 

^| bit 3 (0)


|===

=== ODTCFG

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| WR_ODT_HOLD
^| bit 3..24 (4)


^| bit 3..24 (4)


^| bit 3..24 (4)

| WR_ODT_DELAY
^| bit 4..16 (0)


^| bit 4..16 (0)


^| bit 4..16 (0)

| RD_ODT_HOLD
^| bit 3..8 (4)


^| bit 3..8 (4)


^| bit 3..8 (4)

| RD_ODT_DELAY
^| bit 4..2 (0)


^| bit 4..2 (0)


^| bit 4..2 (0)


|===

=== PCCFG

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| BL_EXP_MODE
^| bit 8 (0)


^| bit 8 (0)


^| bit 8 (0)

| PAGEMATCH_LIMIT
^| bit 4 (0)


^| bit 4 (0)


^| bit 4 (0)

| GO2CRITICAL_EN
^| bit 0 (0)


^| bit 0 (0)


^| bit 0 (0)


|===

=== PGCR2

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DYNACPDD
^| bit 31 (0)


^| 

^| 
| LPMSTRC0
^| bit 30 (0)


^| 

^| 
| ACPDDC
^| bit 29 (0)


^| 

^| 
| SHRAC
^| bit 28 (0)


^| 

^| 
| DTPMXTMR
^| bit 7..20 (15)


^| bit 7..20 (0)


^| bit 7..20 (0)

| FXDLAT
^| bit 19 (0)


^| bit 19 (0)


^| bit 19 (0)

| NOBUB
^| bit 18 (0)


^| 

^| 
| TREFPRD
^| bit 17..0 (74880)


^| bit 17..0 (74880)


^| bit 17..0 (74880)

| CSNCIDMUX
^| 

^| bit 18 (0)


^| bit 18 (0)

| FXDLATINCR
^| 

^| bit 28 (0)


^| bit 28 (0)

| RFSHMODE
^| 

^| bit 1..29 (0)


^| bit 1..29 (0)

| RESERVED_31
^| 

^| bit 31 (0)


^| bit 31 (0)


|===

=== PTR0

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TPLLPD
^| bit 10..21 (534)


^| bit 10..21 (534)


^| bit 10..21 (534)

| TPLLGS
^| bit 14..6 (2134)


^| bit 14..6 (2134)


^| bit 14..6 (2134)

| TPHYRST
^| bit 5..0 (16)


^| bit 5..0 (16)


^| bit 5..0 (16)


|===

=== PTR1

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TPLLLOCK
^| bit 15..16 (53334)


^| bit 16..15 (53334)


^| bit 16..15 (53334)

| TPLLRST
^| bit 12..0 (4800)


^| bit 12..0 (4800)


^| bit 12..0 (4800)

| RESERVED_14_13
^| 

^| bit 1..13 (0)


^| bit 1..13 (0)


|===

=== PTR2

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TWLDLYS
^| bit 4..15 (16)


^| bit 4..15 (16)


^| bit 4..15 (16)

| TCALH
^| bit 4..10 (15)


^| bit 4..10 (15)


^| bit 4..10 (15)

| TCALS
^| bit 4..5 (15)


^| bit 4..5 (15)


^| bit 4..5 (15)

| TCALON
^| bit 4..0 (15)


^| bit 4..0 (15)


^| bit 4..0 (15)

| RESERVED_31_20
^| 

^| bit 11..20 (0)


^| bit 11..20 (0)


|===

=== PTR3

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TDINIT1
^| bit 9..20 (384)


^| bit 9..20 (384)


^| bit 9..20 (384)

| TDINIT0
^| bit 19..0 (533334)


^| bit 19..0 (533334)


^| bit 19..0 (533334)

| RESERVED_31_30
^| 

^| bit 1..30 (0)


^| bit 1..30 (0)


|===

=== PTR4

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TDINIT3
^| bit 9..18 (683)


^| bit 10..18 (800)


^| bit 10..18 (800)

| TDINIT2
^| bit 17..0 (213334)


^| bit 17..0 (213334)


^| bit 17..0 (213334)

| RESERVED_31_29
^| 

^| bit 2..29 (0)


^| bit 2..29 (0)


|===

=== PWRCTL

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DIS_CAM_DRAIN_SELFREF
^| bit 7 (0)


^| bit 7 (0)


^| bit 7 (0)

| SELFREF_SW
^| bit 5 (0)


^| bit 5 (0)


^| bit 5 (0)

| EN_DFI_DRAM_CLK_DISABLE
^| bit 3 (0)


^| bit 3 (0)


^| bit 3 (0)

| POWERDOWN_EN
^| bit 1 (0)


^| bit 1 (0)


^| bit 1 (0)

| SELFREF_EN
^| bit 0 (0)


^| bit 0 (0)


^| bit 0 (0)

| MPSM_EN
^| 

^| bit 4 (0)


^| bit 4 (0)

| DEEPPOWERDOWN_EN
^| 

^| 

^| bit 2 (0)


|===

=== RFSHCTL0

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| REFRESH_MARGIN
^| bit 3..20 (2)


^| bit 3..20 (2)


^| bit 3..20 (2)

| REFRESH_TO_X1_X32
^| bit 4..12 (16)


^| bit 4..12 (16)


^| 
| REFRESH_BURST
^| bit 5..4 (0)


^| bit 5..4 (0)


^| bit 4..4 (0)

| PER_BANK_REFRESH
^| 

^| 

^| bit 2 (0)

| REFRESH_TO_X32
^| 

^| 

^| bit 4..12 (16)


|===

=== RFSHCTL3

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| REFRESH_UPDATE_LEVEL
^| bit 1 (0)


^| bit 1 (0)


^| bit 1 (0)

| DIS_AUTO_REFRESH
^| bit 0 (0)


^| bit 0 (0)


^| bit 0 (0)

| REFRESH_MODE
^| 

^| bit 2..4 (0)


^| bit 2..4 (0)


|===

=== RFSHTMG

Applies to: lan966x
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| T_RFC_NOM_X1_X32
^| bit 11..16 (98)


^| bit 11..16 (98)


^| 
| T_RFC_MIN
^| bit 9..0 (140)


^| bit 9..0 (140)


^| bit 9..0 (140)

| LPDDR3_TREFBW_EN
^| 

^| 

^| bit 15 (0)

| T_RFC_NOM_X32
^| 

^| 

^| bit 11..16 (98)


|===

=== SBRCTL

Applies to: 

sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| SCRUB_INTERVAL
^| bit 12..8 (255)


^| bit 12..8 (255)


^| bit 12..8 (255)

| SCRUB_BURST
^| bit 2..4 (1)


^| bit 2..4 (1)


^| bit 2..4 (1)

| SCRUB_MODE
^| bit 2 (0)


^| bit 2 (0)


^| bit 2 (0)

| SCRUB_DURING_LOWPOWER
^| bit 1 (0)


^| bit 1 (0)


^| bit 1 (0)

| SCRUB_EN
^| bit 0 (0)


^| bit 0 (0)


^| bit 0 (0)


|===

=== SCHCR1

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| RESERVED_1_0
^| 

^| bit 1..0 (0)


^| bit 1..0 (0)

| ALLRANK
^| 

^| bit 2 (0)


^| bit 2 (0)

| RESERVED_3
^| 

^| bit 3 (0)


^| bit 3 (0)

| SCBK
^| 

^| bit 1..4 (0)


^| bit 1..4 (0)

| SCBG
^| 

^| bit 1..6 (0)


^| bit 1..6 (0)

| SCADDR
^| 

^| bit 19..8 (0)


^| bit 19..8 (0)

| SCRNK
^| 

^| bit 3..28 (0)


^| bit 3..28 (0)


|===

=== ZQ0CR0

Applies to: lan966x



[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ZQ0_ZQPD
^| bit 31 (0)


^| 

^| 
| ZQ0_ZCALEN
^| bit 30 (1)


^| 

^| 
| ZQ0_ZCALBYP
^| bit 29 (0)


^| 

^| 
| ZQ0_ZDEN
^| bit 28 (0)


^| 

^| 
| ZQ0_ZDATA
^| bit 27..0 (330)


^| 

^| 

|===

=== ZQ0CR1

Applies to: lan966x



[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ZQ0_DFIPU1
^| bit 17 (0)


^| 

^| 
| ZQ0_DFIPU0
^| bit 16 (0)


^| 

^| 
| ZQ0_DFICCU
^| bit 14 (0)


^| 

^| 
| ZQ0_DFICU1
^| bit 13 (0)


^| 

^| 
| ZQ0_DFICU0
^| bit 12 (1)


^| 

^| 
| ZQ0_ZPROG
^| bit 7..0 (123)


^| 

^| 

|===

=== ZQ0PR

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| RESERVED_7_0
^| 

^| bit 7..0 (0)


^| 
| ZPROG_ASYM_DRV_PU
^| 

^| bit 3..8 (11)


^| bit 3..8 (11)

| ZPROG_ASYM_DRV_PD
^| 

^| bit 3..12 (11)


^| bit 3..12 (11)

| ZPROG_PU_ODT_ONLY
^| 

^| bit 3..16 (7)


^| bit 3..16 (7)

| PU_DRV_ADJUST
^| 

^| bit 1..20 (0)


^| bit 1..20 (0)

| PD_DRV_ADJUST
^| 

^| bit 1..22 (0)


^| bit 1..22 (0)

| RESERVED_27_24
^| 

^| bit 3..24 (0)


^| 
| PU_ODT_ONLY
^| 

^| bit 28 (0)


^| 
| ZSEGBYP
^| 

^| bit 29 (0)


^| 
| ODT_ZDEN
^| 

^| bit 30 (0)


^| 
| DRV_ZDEN
^| 

^| bit 31 (0)


^| 
| ZQDIV
^| 

^| 

^| bit 7..0 (123)

| ZCTRL_UPPER
^| 

^| 

^| bit 3..24 (0)

| RESERVED_31_28
^| 

^| 

^| bit 3..28 (0)


|===

=== ZQ1CR0

Applies to: lan966x



[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ZQ1_ZQPD
^| bit 31 (0)


^| 

^| 
| ZQ1_ZCALEN
^| bit 30 (1)


^| 

^| 
| ZQ1_ZCALBYP
^| bit 29 (0)


^| 

^| 
| ZQ1_ZDEN
^| bit 28 (0)


^| 

^| 
| ZQ1_ZDATA
^| bit 27..0 (330)


^| 

^| 

|===

=== ZQ1CR1

Applies to: lan966x



[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ZQ1_DFIPU1
^| bit 17 (0)


^| 

^| 
| ZQ1_DFIPU0
^| bit 16 (0)


^| 

^| 
| ZQ1_DFICCU
^| bit 14 (0)


^| 

^| 
| ZQ1_DFICU1
^| bit 13 (0)


^| 

^| 
| ZQ1_DFICU0
^| bit 12 (1)


^| 

^| 
| ZQ1_ZPROG
^| bit 7..0 (123)


^| 

^| 

|===

=== ZQ1PR

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| RESERVED_7_0
^| 

^| bit 7..0 (0)


^| 
| ZPROG_ASYM_DRV_PU
^| 

^| bit 3..8 (11)


^| bit 3..8 (11)

| ZPROG_ASYM_DRV_PD
^| 

^| bit 3..12 (11)


^| bit 3..12 (11)

| ZPROG_PU_ODT_ONLY
^| 

^| bit 3..16 (7)


^| bit 3..16 (7)

| PU_DRV_ADJUST
^| 

^| bit 1..20 (0)


^| bit 1..20 (0)

| PD_DRV_ADJUST
^| 

^| bit 1..22 (0)


^| bit 1..22 (0)

| RESERVED_27_24
^| 

^| bit 3..24 (0)


^| 
| PU_ODT_ONLY
^| 

^| bit 28 (0)


^| 
| ZSEGBYP
^| 

^| bit 29 (0)


^| 
| ODT_ZDEN
^| 

^| bit 30 (0)


^| 
| DRV_ZDEN
^| 

^| bit 31 (0)


^| 
| ZQDIV
^| 

^| 

^| bit 7..0 (123)

| ZCTRL_UPPER
^| 

^| 

^| bit 3..24 (0)

| RESERVED_31_28
^| 

^| 

^| bit 3..28 (0)


|===

=== ZQ2PR

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| RESERVED_7_0
^| 

^| bit 7..0 (0)


^| 
| ZPROG_ASYM_DRV_PU
^| 

^| bit 3..8 (0)


^| bit 3..8 (11)

| ZPROG_ASYM_DRV_PD
^| 

^| bit 3..12 (0)


^| bit 3..12 (11)

| ZPROG_PU_ODT_ONLY
^| 

^| bit 3..16 (0)


^| bit 3..16 (7)

| PU_DRV_ADJUST
^| 

^| bit 1..20 (0)


^| bit 1..20 (0)

| PD_DRV_ADJUST
^| 

^| bit 1..22 (0)


^| bit 1..22 (0)

| RESERVED_27_24
^| 

^| bit 3..24 (0)


^| 
| PU_ODT_ONLY
^| 

^| bit 28 (0)


^| 
| ZSEGBYP
^| 

^| bit 29 (0)


^| 
| ODT_ZDEN
^| 

^| bit 30 (0)


^| 
| DRV_ZDEN
^| 

^| bit 31 (0)


^| 
| ZQDIV
^| 

^| 

^| bit 7..0 (123)

| ZCTRL_UPPER
^| 

^| 

^| bit 3..24 (0)

| RESERVED_31_28
^| 

^| 

^| bit 3..28 (0)


|===

=== ZQCR

Applies to: 
lan969x
sparx5

[cols="1s,1,1,1"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| RESERVED_0
^| 

^| bit 0 (0)


^| bit 0 (0)

| TERM_OFF
^| 

^| bit 1 (0)


^| bit 1 (0)

| ZQPD
^| 

^| bit 2 (0)


^| bit 2 (0)

| RESERVED_7_3
^| 

^| bit 4..3 (0)


^| bit 4..3 (0)

| PGWAIT
^| 

^| bit 2..8 (5)


^| bit 2..8 (5)

| ZCALT
^| 

^| bit 2..11 (1)


^| bit 2..11 (1)

| AVGMAX
^| 

^| bit 1..14 (2)


^| bit 1..14 (2)

| AVGEN
^| 

^| bit 16 (1)


^| bit 16 (1)

| IODLMT
^| 

^| bit 7..17 (2)


^| bit 6..17 (2)

| RESERVED_26_25
^| 

^| bit 1..25 (0)


^| 
| FORCE_ZCAL_VT_UPDATE
^| 

^| bit 27 (0)


^| bit 27 (0)

| RESERVED_31_28
^| 

^| bit 3..28 (0)


^| 
| ASYM_DRV_EN
^| 

^| 

^| bit 24 (0)

| PU_ODT_ONLY
^| 

^| 

^| bit 25 (0)

| DIS_NON_LIN_COMP
^| 

^| 

^| bit 26 (1)

| ZCTRL_UPPER
^| 

^| 

^| bit 3..28 (0)


|===


== Register documentation reference

[cols="1s,1,1,1"]
|===
| Register
^s| lan966x
^s| lan969x
^s| sparx5

| xref:ADDRMAP0 fields[ADDRMAP0]

| Address Map Register 0

| Address Map Register 0

| Address Map Register 0
| xref:ADDRMAP1 fields[ADDRMAP1]

| Address Map Register 1

| Address Map Register 1

| Address Map Register 1
| xref:ADDRMAP2 fields[ADDRMAP2]

| Address Map Register 2

| Address Map Register 2

| Address Map Register 2
| xref:ADDRMAP3 fields[ADDRMAP3]

| Address Map Register 3

| Address Map Register 3

| Address Map Register 3
| xref:ADDRMAP4 fields[ADDRMAP4]

| Address Map Register 4

| Address Map Register 4

| Address Map Register 4
| xref:ADDRMAP5 fields[ADDRMAP5]

| Address Map Register 5

| Address Map Register 5

| Address Map Register 5
| xref:ADDRMAP6 fields[ADDRMAP6]

| Address Map Register 6

| Address Map Register 6

| Address Map Register 6
| xref:ADDRMAP7 fields[ADDRMAP7]
| -

| Address Map Register 7

| Address Map Register 7
| xref:ADDRMAP8 fields[ADDRMAP8]
| -

| Address Map Register 8

| Address Map Register 8
| xref:CRCPARCTL1 fields[CRCPARCTL1]
| -

| CRC Parity Control Register 1

| CRC Parity Control Register1
| xref:DBICTL fields[DBICTL]
| -

| DM/DBI Control Register

| DM/DBI Control Register
| xref:DCR fields[DCR]

| DRAM Configuration Register

| DRAM Configuration Register

| DRAM Configuration Register
| xref:DFIMISC fields[DFIMISC]

| DFI Miscellaneous Control Register

| DFI Miscellaneous Control Register

| DFI Miscellaneous Control Register
| xref:DFITMG0 fields[DFITMG0]

| DFI Timing Register 0

| DFI Timing Register 0

| DFI Timing Register 0
| xref:DFITMG1 fields[DFITMG1]

| DFI Timing Register 1

| DFI Timing Register 1

| DFI Timing Register 1
| xref:DFIUPD0 fields[DFIUPD0]

| DFI Update Register 0

| DFI Update Register 0

| DFI Update Register 0
| xref:DFIUPD1 fields[DFIUPD1]

| DFI Update Register 1

| DFI Update Register 1

| DFI Update Register 1
| xref:DRAMTMG0 fields[DRAMTMG0]

| SDRAM Timing Register 0

| SDRAM Timing Register 0

| SDRAM Timing Register 0
| xref:DRAMTMG1 fields[DRAMTMG1]

| SDRAM Timing Register 1

| SDRAM Timing Register 1

| SDRAM Timing Register 1
| xref:DRAMTMG12 fields[DRAMTMG12]
| -

| SDRAM Timing Register 12

| SDRAM Timing Register 12
| xref:DRAMTMG2 fields[DRAMTMG2]

| SDRAM Timing Register 2

| SDRAM Timing Register 2

| SDRAM Timing Register 2
| xref:DRAMTMG3 fields[DRAMTMG3]

| SDRAM Timing Register 3

| SDRAM Timing Register 3

| SDRAM Timing Register 3
| xref:DRAMTMG4 fields[DRAMTMG4]

| SDRAM Timing Register 4

| SDRAM Timing Register 4

| SDRAM Timing Register 4
| xref:DRAMTMG5 fields[DRAMTMG5]

| SDRAM Timing Register 5

| SDRAM Timing Register 5

| SDRAM Timing Register 5
| xref:DRAMTMG8 fields[DRAMTMG8]

| SDRAM Timing Register 8

| SDRAM Timing Register 8

| SDRAM Timing Register 8
| xref:DRAMTMG9 fields[DRAMTMG9]
| -

| SDRAM Timing Register 9

| SDRAM Timing Register 9
| xref:DSGCR fields[DSGCR]

| DDR System General Configuration Register

| DDR System General Configuration Register

| DDR System General Configuration Register
| xref:DTCR fields[DTCR]

| Data Training Configuration Register
| -
| -
| xref:DTCR0 fields[DTCR0]
| -

| Data Training Configuration Register 0

| Data Training Configuration Register 0
| xref:DTCR1 fields[DTCR1]
| -

| Data Training Configuration Register 1

| Data Training Configuration Register 1
| xref:DTPR0 fields[DTPR0]

| DRAM Timing Parameters Register 0

| DRAM Timing Parameters Register 0

| DRAM Timing Parameters Register 0
| xref:DTPR1 fields[DTPR1]

| DRAM Timing Parameters Register 1

| DRAM Timing Parameters Register 1

| DRAM Timing Parameters Register 1
| xref:DTPR2 fields[DTPR2]

| DRAM Timing Parameters Register 2

| DRAM Timing Parameters Register 2

| DRAM Timing Parameters Register 2
| xref:DTPR3 fields[DTPR3]
| -

| DRAM Timing Parameters Register 3

| DRAM Timing Parameters Register 3
| xref:DTPR4 fields[DTPR4]
| -

| DRAM Timing Parameters Register 4

| DRAM Timing Parameters Register 4
| xref:DTPR5 fields[DTPR5]
| -

| DRAM Timing Parameters Register 5

| DRAM Timing Parameters Register 5
| xref:DXCCR fields[DXCCR]

| DATX8 Common Configuration Register

| DATX8 Common Configuration Register

| DATX8 Common Configuration Register
| xref:ECCCFG0 fields[ECCCFG0]

| ECC Configuration Register 0

| ECC Configuration Register 0

| ECC Configuration Register 0
| xref:INIT0 fields[INIT0]

| SDRAM Initialization Register 0

| SDRAM Initialization Register 0

| SDRAM Initialization Register 0
| xref:INIT1 fields[INIT1]

| SDRAM Initialization Register 1

| SDRAM Initialization Register 1

| SDRAM Initialization Register 1
| xref:INIT3 fields[INIT3]

| SDRAM Initialization Register 3

| SDRAM Initialization Register 3

| SDRAM Initialization Register 3
| xref:INIT4 fields[INIT4]

| SDRAM Initialization Register 4

| SDRAM Initialization Register 4

| SDRAM Initialization Register 4
| xref:INIT5 fields[INIT5]

| SDRAM Initialization Register 5

| SDRAM Initialization Register 5

| SDRAM Initialization Register 5
| xref:INIT6 fields[INIT6]
| -

| SDRAM Initialization Register 6

| SDRAM Initialization Register 6
| xref:INIT7 fields[INIT7]
| -

| SDRAM Initialization Register 7

| SDRAM Initialization Register 7
| xref:MSTR fields[MSTR]

| Master Register0

| Master Register 0

| Master Register0
| xref:ODTCFG fields[ODTCFG]

| ODT Configuration Register

| ODT Configuration Register

| ODT Configuration Register
| xref:PCCFG fields[PCCFG]

| Port Common Configuration Register

| Port Common Configuration Register

| Port Common Configuration Register
| xref:PGCR2 fields[PGCR2]

| PHY General Configuration Register 2

| PHY General Configuration Register 2

| PHY General Configuration Register 2
| xref:PTR0 fields[PTR0]

| PHY Timing Register 0

| PHY Timing Register 0

| PHY Timing Register 0
| xref:PTR1 fields[PTR1]

| PHY Timing Register 1

| PHY Timing Register 1

| PHY Timing Register 1
| xref:PTR2 fields[PTR2]

| PHY Timing Register 2

| PHY Timing Register 2

| PHY Timing Register 2
| xref:PTR3 fields[PTR3]

| PHY Timing Register 3

| PHY Timing Register 3

| PHY Timing Register 3
| xref:PTR4 fields[PTR4]

| PHY Timing Register 4

| PHY Timing Register 4

| PHY Timing Register 4
| xref:PWRCTL fields[PWRCTL]

| Low Power Control Register

| Low Power Control Register

| Low Power Control Register
| xref:RFSHCTL0 fields[RFSHCTL0]

| Refresh Control Register 0

| Refresh Control Register 0

| Refresh Control Register 0
| xref:RFSHCTL3 fields[RFSHCTL3]

| Refresh Control Register 3

| Refresh Control Register 3

| Refresh Control Register 3
| xref:RFSHTMG fields[RFSHTMG]

| Refresh Timing Register

| Refresh Timing Register

| Refresh Timing Register
| xref:SBRCTL fields[SBRCTL]

| Scrubber Control Register

| Scrubber Control Register

| Scrubber Control Register
| xref:SCHCR1 fields[SCHCR1]
| -

| Scheduler Command Register 1

| Scheduler Command Register 1
| xref:ZQ0CR0 fields[ZQ0CR0]

| ZQ n Impedance Control Register 0
| -
| -
| xref:ZQ0CR1 fields[ZQ0CR1]

| ZQ n Impedance Control Register 1
| -
| -
| xref:ZQ0PR fields[ZQ0PR]
| -

| ZQ n Impedance Control Program Register

| ZQ n Impedance Control Program Register
| xref:ZQ1CR0 fields[ZQ1CR0]

| ZQ n Impedance Control Register 0
| -
| -
| xref:ZQ1CR1 fields[ZQ1CR1]

| ZQ n Impedance Control Register 1
| -
| -
| xref:ZQ1PR fields[ZQ1PR]
| -

| ZQ n Impedance Control Program Register

| ZQ n Impedance Control Program Register
| xref:ZQ2PR fields[ZQ2PR]
| -

| ZQ n Impedance Control Program Register

| ZQ n Impedance Control Program Register
| xref:ZQCR fields[ZQCR]
| -

| ZQ Impedance Control Register

| ZQ Impedance Control Register
|===

== Register fields documentation reference


=== ADDRMAP0 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_CS_BIT0

 3+| Selects the HIF address bit used as rank address bit 0. Valid Range: 0 to 29, and 31 Internal Base: 6 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 31 and then rank address bit 0 is set to 0. Programming Mode: Static

|===


=== ADDRMAP1 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_BANK_B2

 2+| Selects the HIF address bit used as bank address bit 2. Valid Range: 0 to 31, and 63 Internal Base: 4 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank address bit 2 is set to 0. Programming Mode: Static | Selects the HIF address bit used as bank address bit 2. Valid Range: 0 to 31 and 63 Internal Base: 4 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank address bit 2 is set to 0. Programming Mode: Static

| ADDRMAP_BANK_B1

 2+| Selects the HIF address bits used as bank address bit 1. Valid Range: 0 to 32, and 63 Internal Base: 3 The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank address bit 1 is set to 0. Programming Mode: Static | Selects the HIF address bits used as bank address bit 1. Valid Range: 0 to 32 and 63 Internal Base: 3 The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank address bit 1 is set to 0. Programming Mode: Static

| ADDRMAP_BANK_B0

 2+| Selects the HIF address bits used as bank address bit 0. Valid Range: 0 to 32, and 63 Internal Base: 2 The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank address bit 0 is set to 0. Programming Mode: Static | Selects the HIF address bits used as bank address bit 0. Valid Range: 0 to 32 and 63 Internal Base: 2 The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank address bit 0 is set to 0. Programming Mode: Static

|===


=== ADDRMAP2 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_COL_B5

 2+|   - Full bus width mode - Selects the HIF address bit used as column address bit 5  - Half bus width mode - Selects the HIF address bit used as column address bit 6  - Quarter bus width mode - Selects the HIF address bit used as column address bit 7  Valid Range: 0 to 7, and 15 Internal Base: 5 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then this column address bit is set to 0. Programming Mode: Static |    - Full bus width mode: Selects the HIF address bit used as column address bit 5.    - Half bus width mode: Selects the HIF address bit used as column address bit 6.    - Quarter bus width mode: Selects the HIF address bit used as column address bit 7 . Valid Range: 0 to 7, and 15 Internal Base: 5 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then this column address bit is set to 0. Programming Mode: Static

| ADDRMAP_COL_B4

 2+|   - Full bus width mode - Selects the HIF address bit used as column address bit 4  - Half bus width mode - Selects the HIF address bit used as column address bit 5  - Quarter bus width mode - Selects the HIF address bit used as column address bit 6 Valid Range: 0 to 7, and 15 Internal Base: 4 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then this column address bit is set to 0. Programming Mode: Static |    - Full bus width mode: Selects the HIF address bit used as column address bit 4.    - Half bus width mode: Selects the HIF address bit used as column address bit 5.    - Quarter bus width mode: Selects the HIF address bit used as column address bit 6. Valid Range: 0 to 7, and 15 Internal Base: 4 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then this column address bit is set to 0. Programming Mode: Static

| ADDRMAP_COL_B3

 2+|   - Full bus width mode - Selects the HIF address bit used as column address bit 3  - Half bus width mode - Selects the HIF address bit used as column address bit 4  - Quarter bus width mode - Selects the HIF address bit used as column address bit 5 Valid Range: 0 to 7, x. x indicates a valid value in the inline ECC configuration.  Internal Base: 3 The selected HIF address bit is determined by adding the internal base to the value of this field. Note, if UMCTL2_INCL_ARB=1, MEMC_BURST_LENGTH=16, Full bus width (MSTR.data_bus_width=00) and BL16 (MSTR.burst_rdwr=1000), it is recommended to program this to 0.  In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), if MEMC_BURST_LENGTH is 16, number of column address is 10 and work on half bus width mode, column bit 8, column bit 7 and column bit 3 must map to the highest 3 valid HIF address bits. This register need be set to x. (x = the highest valid HIF address bit - internal base - 2) Programming Mode: Static |    - Full bus width mode: Selects the HIF address bit used as column address bit 3.     - Half bus width mode: Selects the HIF address bit used as column address bit 4.    - Quarter bus width mode: Selects the HIF address bit used as column address bit 5. Valid Range: 0 to 7 Internal Base: 3 The selected HIF address bit is determined by adding the internal base to the value of this field.   Note, if UMCTL2_INCL_ARB=1, MEMC_BURST_LENGTH=16, Full bus width (MSTR.data_bus_width=00) and BL16 (MSTR.burst_rdwr=1000), it is recommended to program this to 0.   Programming Mode: Static

| ADDRMAP_COL_B2

 2+|   - Full bus width mode - Selects the HIF address bit used as column address bit 2  - Half bus width mode - Selects the HIF address bit used as column address bit 3  - Quarter bus width mode - Selects the HIF address bit used as column address bit 4 Valid Range: 0 to 7 Internal Base: 2 The selected HIF address bit is determined by adding the internal base to the value of this field.  Note, if UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=8, it is required to program this to 0 unless:  - In Half or Quarter bus width (MSTR.data_bus_width!=00) and  - PCCFG.bl_exp_mode==1 and either  - In DDR4 and ADDRMAP8.addrmap_bg_b0==0 or  - In LPDDR4 and ADDRMAP1.addrmap_bank_b0==0 If UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=16, it is required to program this to 0 unless:  - In Half or Quarter bus width (MSTR.data_bus_width!=00) and   - PCCFG.bl_exp_mode==1 and  - In DDR4 and ADDRMAP8.addrmap_bg_b0==0 Otherwise, if MEMC_BURST_LENGTH=8 and Full Bus Width (MSTR.data_bus_width==00), it is recommended to program this to 0 so that HIF[2] maps to column address bit 2.  If MEMC_BURST_LENGTH=16 and Full Bus Width (MSTR.data_bus_width==00), it is recommended to program this to 0 so that HIF[2] maps to column address bit 2. If MEMC_BURST_LENGTH=16 and Half Bus Width (MSTR.data_bus_width==01), it is recommended to program this to 0 so that HIF[2] maps to column address bit 3.  Programming Mode: Static |    - Full bus width mode: Selects the HIF address bit used as column address bit 2.    - Half bus width mode: Selects the HIF address bit used as column address bit 3.    - Quarter bus width mode: Selects the HIF address bit used as column address bit 4. Valid Range: 0 to 7 Internal Base: 2 The selected HIF address bit is determined by adding the internal base to the value of this field.   Note, if UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=8, it is required to program this to 0 unless:   - in Half or Quarter bus width (MSTR.data_bus_width!=00) and   - PCCFG.bl_exp_mode==1 and either   - In DDR4   and ADDRMAP8.addrmap_bg_b0==0 or   - In LPDDR4 and ADDRMAP1.addrmap_bank_b0==0   If UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=16, it is required to program this to 0 unless:   - in Half or Quarter bus width (MSTR.data_bus_width!=00) and    - PCCFG.bl_exp_mode==1 and   - In DDR4 and ADDRMAP8.addrmap_bg_b0==0  Otherwise, if MEMC_BURST_LENGTH=8 and Full Bus Width (MSTR.data_bus_width==00), it is recommended to program this to 0 so that HIF[2] maps to column address bit 2.  If MEMC_BURST_LENGTH=16 and Full Bus Width (MSTR.data_bus_width==00), it is recommended to program this to 0 so that HIF[2] maps to column address bit 2.  If MEMC_BURST_LENGTH=16 and Half Bus Width (MSTR.data_bus_width==01), it is recommended to program this to 0 so that HIF[2] maps to column address bit 3.   Programming Mode: Static

|===


=== ADDRMAP3 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_COL_B9

 2+|   - Full bus width mode - Selects the HIF address bit used as column address bit 9  - Half bus width mode - Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode)  - Quarter bus width mode - Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode) Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 9 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used. In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), the highest 3 column address bits must map to the highest 3 valid HIF address bits. If column bit 9 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base) If column bit 9 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base) If column bit 9 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base) If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static |    - Full bus width mode: Selects the HIF address bit used as column address bit 9.    - Half bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode).    - Quarter bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode). Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration. Internal Base: 9 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 31 and then this column address bit is set to 0. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode&gt;0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.    If column bit 9 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base)    If column bit 9 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)    If column bit 9 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)    if it is unused, set to 31. Programming Mode: Static

| ADDRMAP_COL_B8

 2+|   - Full bus width mode - Selects the HIF address bit used as column address bit 8  - Half bus width mode - Selects the HIF address bit used as column address bit 9  - Quarter bus width mode - Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode) Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 8 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used. In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), the highest 3 column address bits must map to the highest 3 valid HIF address bits. If column bit 8 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base) If column bit 8 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base) If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static |    - Full bus width mode: Selects the HIF address bit used as column address bit 8.    - Half bus width mode: Selects the HIF address bit used as column address bit 9.    - Quarter bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode). Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration. Internal Base: 8 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 31 and then this column address bit is set to 0. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode&gt;0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.    If column bit 8 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)    If column bit 8 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)    if it is unused, set to 31. Programming Mode: Static

| ADDRMAP_COL_B7

 2+|   - Full bus width mode - Selects the HIF address bit used as column address bit 7  - Half bus width mode - Selects the HIF address bit used as column address bit 8  - Quarter bus width mode - Selects the HIF address bit used as column address bit 9 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 7  The selected HIF address bit is determined by adding the internal base to the value of this field.  In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), the highest 3 column address bits must map to the highest 3 valid HIF address bits. If column bit 7 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base) If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static |    - Full bus width mode: Selects the HIF address bit used as column address bit 7.    - Half bus width mode: Selects the HIF address bit used as column address bit 8.    - Quarter bus width mode: Selects the HIF address bit used as column address bit 9. Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration. Internal Base: 7  The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 31 and then this column address bit is set to 0.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode&gt;0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.    If column bit 7 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)    if it is unused, set to 31. Programming Mode: Static

| ADDRMAP_COL_B6

 2+|   - Full bus width mode - Selects the HIF address bit used as column address bit 6.  - Half bus width mode - Selects the HIF address bit used as column address bit 7.  - Quarter bus width mode - Selects the HIF address bit used as column address bit 8. Valid Range: 0 to 7, x and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 6 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 31 and then this column address bit is set to 0. In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), if MEMC_BURST_LENGTH is 8, number of column address is 10 and work on half bus width mode, column bit 8, column bit 7 and column bit 6 must map to the highest 3 valid HIF address bits. This register need be set to x. (x = the highest valid HIF address bit - internal base - 2) Programming Mode: Static |    - Full bus width mode: Selects the HIF address bit used as column address bit 6.    - Half bus width mode: Selects the HIF address bit used as column address bit 7.    - Quarter bus width mode: Selects the HIF address bit used as column address bit 8. Valid Range: 0 to 7, and 15 Internal Base: 6 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then this column address bit is set to 0. Programming Mode: Static

|===


=== ADDRMAP4 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_COL_B11

 2+|   - Full bus width mode - Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode)  - Half bus width mode - UNUSED. See later in this description for value you need to set to make it unused  - Quarter bus width mode - UNUSED. See later in this description for value you need to set to make it unused Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 11 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used. In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), the highest 3 column address bits must map to the highest 3 valid HIF address bits. If column bit 11 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base) If column bit 11 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base) If column bit 11 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base) If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static |    - Full bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode).    - Half bus width mode: Unused. To make it unused, this should be tied to 4'hF.    - Quarter bus width mode: Unused. To make it unused, this must be tied to 4'hF. Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration. Internal Base: 11 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 31 and then this column address bit is set to 0. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode&gt;0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.    If column bit 11 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base)    If column bit 11 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)    If column bit 11 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)    if it is unused, set to 31. Programming Mode: Static

| ADDRMAP_COL_B10

 2+|   - Full bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode)  - Half bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode)  - Quarter bus width mode: UNUSED. See later in this description for value you need to set to make it unused Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 10 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used. In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), the highest 3 column address bits must map to the highest 3 valid HIF address bits. If column bit 10 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base) If column bit 10 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base) If column bit 10 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base) If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static |    - Full bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode).    - Half bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode).    - Quarter bus width mode: UNUSED. To make it unused, this must be tied to 4'hF. Valid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration. Internal Base: 10 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 31 and then this column address bit is set to 0.  Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.    In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled (ECCCFG0.ecc_mode&gt;0), the highest 3 column address bits must map to the highest 3 valid HIF address bits.    If column bit 10 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base)    If column bit 10 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)    If column bit 10 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base)    if it is unused, set to 31. Programming Mode: Static

|===


=== ADDRMAP5 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_ROW_B11

 3+| Selects the HIF address bit used as row address bit 11. Valid Range: 0 to 11, and 15 Internal Base: 17 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 11 is set to 0. Programming Mode: Static

| ADDRMAP_ROW_B2_10

 2+| Selects the HIF address bits used as row address bits 2 to 10. Valid Range: 0 to 11, and 15 Internal Base: 8 (for row address bit 2), 9 (for row address bit 3), 10 (for row address bit 4) and so on, increasing to 16 (for row address bit 10) The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. When set to 15, the values of row address bits 2 to 10 are defined by registers ADDRMAP9, ADDRMAP10, ADDRMAP11. Programming Mode: Static | Selects the HIF address bits used as row address bits 2 to 10. Valid Range: 0 to 11, and 15 Internal Base: 8 (for row address bit 2), 9 (for row address bit 3), 10 (for row address bit 4) etc increasing to 16 (for row address bit 10) The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. When value 15 is used the values of row address bits 2 to 10 are defined by registers ADDRMAP9, ADDRMAP10, ADDRMAP11. Programming Mode: Static

| ADDRMAP_ROW_B1

 3+| Selects the HIF address bits used as row address bit 1. Valid Range: 0 to 11 Internal Base: 7 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. Programming Mode: Static

| ADDRMAP_ROW_B0

 3+| Selects the HIF address bits used as row address bit 0. Valid Range: 0 to 11 Internal Base: 6 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. Programming Mode: Static

|===


=== ADDRMAP6 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_ROW_B15

 3+| Selects the HIF address bit used as row address bit 15. Valid Range: 0 to 11, and 15 Internal Base: 21 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 15 is set to 0. Programming Mode: Static

| ADDRMAP_ROW_B14

 3+| Selects the HIF address bit used as row address bit 14. Valid Range: 0 to 11, and 15 Internal Base: 20 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 14 is set to 0. Programming Mode: Static

| ADDRMAP_ROW_B13

 3+| Selects the HIF address bit used as row address bit 13. Valid Range: 0 to 11, and 15 Internal Base: 19 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 13 is set to 0. Programming Mode: Static

| ADDRMAP_ROW_B12

 3+| Selects the HIF address bit used as row address bit 12. Valid Range: 0 to 11, and 15 Internal Base: 18 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 12 is set to 0. Programming Mode: Static

| LPDDR3_6GB_12GB

 2+|  |   Set this to 1 if there is an LPDDR3 SDRAM 6Gb or 12Gb device in use.  - 1 - LPDDR3 SDRAM 6Gb/12Gb device in use. Every address having row[14:13]==2'b11 is considered as invalid  - 0 - non-LPDDR3 6Gb/12Gb device in use. All addresses are valid Present only in designs configured to support LPDDR3. Programming Mode: Static

|===


=== ADDRMAP7 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_ROW_B16

 |  2+| Selects the HIF address bit used as row address bit 16. Valid Range: 0 to 11, and 15 Internal Base: 22 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 16 is set to 0. Programming Mode: Static

| ADDRMAP_ROW_B17

 |  | Selects the HIF address bit used as row address bit 17. Valid Range: 0 to 11, and 15 Internal Base: 23 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 17 is set to 0 for DDR4 or set to 1 for LPDDR4 backward compability. Programming Mode: Static | Selects the HIF address bit used as row address bit 17. Valid Range: 0 to 11, and 15 Internal Base: 23 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 17 is set to 0. Programming Mode: Static

|===


=== ADDRMAP8 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ADDRMAP_BG_B0

 |  | Selects the HIF address bits used as bank group address bit 0. Valid Range: 0 to 32, and 63 Internal Base: 2 The selected HIF address bit for each of the bank group address bits is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank group address bit 0 is set to 0. Programming Mode: Static | Selects the HIF address bits used as bank group address bit 0. Valid Range: 0 to 32 and 63 Internal Base: 2 The selected HIF address bit for each of the bank group address bits is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank group address bit 0 is set to 0. Programming Mode: Static

| ADDRMAP_BG_B1

 |  2+| Selects the HIF address bits used as bank group address bit 1. Valid Range: 0 to 32, and 63 Internal Base: 3 The selected HIF address bit for each of the bank group address bits is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank group address bit 1 is set to 0. Programming Mode: Static

|===


=== CRCPARCTL1 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| PARITY_ENABLE

 |  | C/A Parity enable register.    If RCD's parity error detection or SDRAM's parity detection is enabled, this register must be 1. Programming Mode: Static | C/A Parity enable register      - 1: Enable generation of C/A parity and detection of C/A parity error      - 0: Disable generation of C/A parity and disable detection of C/A parity error      If RCD's parity error detection or SDRAM's parity detection is enabled, this register should be 1. Programming Mode: Static

| CRC_ENABLE

 |  | CRC enable Register.    The setting of this register must match the CRC mode register setting in the DRAM. Programming Mode: Quasi-dynamic Group 2 | CRC enable Register      - 1: Enable generation of CRC      - 0: Disable generation of CRC  The setting of this register should match the CRC mode register setting in the DRAM. Programming Mode: Static

| CRC_INC_DM

 |  | CRC calculation setting register.    Present only in designs configured to support DDR4. Programming Mode: Static | CRC Calculation setting register      - 1: CRC includes DM signal      - 0: CRC not includes DM signal  Present only in designs configured to support DDR4. Programming Mode: Static

| CAPARITY_DISABLE_BEFORE_SR

 |  | If DDR4-SDRAM's CA parity is enabled by INIT6.mr5[2:0]!=0 and this register is set to 1, CA parity is automatically disabled before self-refresh entry, and enabled after self-refresh exit by issuing MR5.    If Geardown is used by MSTR.geardown_mode=1, this register must be set to 1. If this register set to 0, DRAMTMG5.t_ckesr and DRAMTMG5.t_cksre must be increased by PL(Parity latency). Programming Mode: Static | If DDR4-SDRAM's CA parity is enabled by INIT6.mr5[2:0]!=0 and this register is set to 1, CA parity is automatically disabled before Self-Refresh entry and enabled after Self-Refresh exit by issuing MR5.      - 1: CA parity is disabled before Self-Refresh entry      - 0: CA parity is not disabled before Self-Refresh entry  If Geardown is used by MSTR.geardown_mode=1, this register must be set to 1.  If this register set to 0, DRAMTMG5.t_ckesr and DRAMTMG5.t_cksre must be increased by PL(Parity latency)   Programming Mode: Static

|===


=== DBICTL fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DM_EN

 |  | Indicates the DM enable signal in DDRC.    This signal must be set the same logical value as DRAM's mode register.  - DDR4 - Set this to same value as MR5 bit A10. When x4 devices are used, this signal must be set to 0  - LPDDR4 - Set this to inverted value of MR13[5] which is opposite polarity from this signal Programming Mode: Static | DM enable signal in DDRC.   - 0 - DM is disabled.   - 1 - DM is enabled. This signal must be set the same logical value as DRAM's mode register.   - DDR4:   Set this to same value as MR5 bit A10. When x4 devices are used, this signal must be set to 0.   - LPDDR4: Set this to inverted value of MR13[5] which is opposite polarity from this signal Programming Mode: Quasi-dynamic Group 3

| WR_DBI_EN

 |  | Write DBI enable signal in DDRC.    This signal must be set the same value as DRAM's mode register.  - DDR4 - MR5 bit A11. When x4 devices are used, this signal must be set to 0  - LPDDR4 - MR3[7] Programming Mode: Quasi-dynamic Group 1 | Write DBI enable signal in DDRC.   - 0 - Write DBI is disabled.   - 1 - Write DBI is enabled. This signal must be set the same value as DRAM's mode register.   - DDR4:   MR5 bit A11. When x4 devices are used, this signal must be set to 0.   - LPDDR4: MR3[7] Programming Mode: Quasi-dynamic Group 1

| RD_DBI_EN

 |  | Read DBI enable signal in DDRC.    This signal must be set the same value as DRAM's mode register.  - DDR4 - MR5 bit A12. When x4 devices are used, this signal must be set to 0  - LPDDR4 - MR3[6] Programming Mode: Quasi-dynamic Group 1 | Read DBI enable signal in DDRC.   - 0 - Read DBI is disabled.   - 1 - Read DBI is enabled. This signal must be set the same value as DRAM's mode register.   - DDR4:   MR5 bit A12. When x4 devices are used, this signal must be set to 0.   - LPDDR4: MR3[6] Programming Mode: Quasi-dynamic Group 1

|===


=== DCR fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| UDIMM

 | Un-buffered DIMM Address Mirroring: Indicates, if set, that there is address mirroring on the second rank of an un-buffered DIMM (the rank connected to CS#[1]). In this case, the PUB re-scrambles the bank and address when sending mode register commands to the second rank. This only applies to PUB internal SDRAM transactions. Transactions generated by the controller must make its own adjustments when using an un-buffered DIMM. DCR[NOSRA] must be set if address mirroring is enabled. 2+| Un-buffered DIMM Address Mirroring.

| DDR2T

 | DDR 2T Timing: Indicates, if set, that 2T timing should be used by PUB internally generated SDRAM transactions. 2+| DDR 2T Timing.

| NOSRA

 | No Simultaneous Rank Access: Specifies, if set, that simultaneous rank access on the same clock cycle is not allowed. This means that multiple chip select signals should not be asserted at the same time. This may be required on some DIMM systems. 2+| No Simultaneous Rank Access.

| BYTEMASK

 | Byte Mask: Mask applied to all beats of read data on all bytes lanes during read DQS gate training. This allows training to be conducted based on selected bit(s) from the byte lanes. Valid values for each bit are: 0 = Disable compare for that bit 1 = Enable compare for that bit Note that this mask applies in DDR3 MPR operation mode as well and must be in keeping with the PDQ field setting. 2+| Byte Mask.

| MPRDQ

 | Multi-Purpose Register (MPR) DQ (DDR3 Only): Specifies the value that is driven on non-primary DQ pins during MPR reads. Valid values are: 0 = Primary DQ drives out the data from MPR (0-1-0-1); non-primary DQs drive '0' 1 = Primary DQ and non-primary DQs all drive the same data from MPR (0-1-0-1) 2+| Multi-Purpose Register (MPR) DQ.

| PDQ

 | Primary DQ (DDR3 Only): Specifies the DQ pin in a byte that is designated as a primary pin for Multi-Purpose Register (MPR) reads. Valid values are 0 to 7 for DQ[0] to DQ[7], respectively. 2+| Primary DQ.

| DDR8BNK

 | DDR 8-Bank: Indicates, if set, that the SDRAM used has 8 banks. tRPA = tRP+1 and tFAW are used for 8-bank DRAMs, otherwise tRPA = tRP and no tFAW is used. Note that a setting of 1 for DRAMs that have fewer than 8 banks results in correct functionality, but less tight DRAM command spacing for the parameters. 2+| DDR 8-Bank.

| DDRMD

 | DDR Mode: SDRAM DDR mode. Valid values are: 000 = Reserved 001 = Reserved 010 = DDR2 011 = DDR3 100 - 111 = Reserved 2+| DDR Mode.

| DDRTYPE

 |  2+| DDR Type.

| RESERVED_26_18

 |  2+| Reserved for future use.

| UBG

 |  2+| Un-used Bank Group.

| RESERVED_31

 |  2+| Reserved for future use.

|===


=== DFIMISC fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DFI_FREQUENCY

 3+| Indicates the operating frequency of the system. The number of supported frequencies and the mapping of signal values to clock frequencies are defined by the PHY. Programming Mode: Quasi-dynamic Group 1

| DFI_INIT_START

 | PHY init start request signal.When asserted it triggers the PHY init start request. Programming Mode: Quasi-dynamic Group 3 | PHY init start request signal. Programming Mode: Quasi-dynamic Group 3 | PHY init start request signal.When asserted it triggers the PHY init start request Programming Mode: Quasi-dynamic Group 3

| CTL_IDLE_EN

 | Enables support of ctl_idle signal, which is non-DFI related pin specific to certain Synopsys PHYs. For more information on ctl_idle functionality, see signal description of ctl_idle signal.   Programming Mode: Static | Sets support of ctl_idle signal, which is non-DFI related pin specific to certain Synopsys PHYs. For more information on ctl_idle functionality, see signal description of ctl_idle signal.   Programming Mode: Static | Enables support of ctl_idle signal, which is non-DFI related pin specific to certain Synopsys PHYs. See signal description of ctl_idle signal for further details of ctl_idle functionality.   Programming Mode: Static

| DFI_INIT_COMPLETE_EN

 | PHY initialization complete enable signal. When asserted the dfi_init_complete signal can be used to trigger SDRAM initialisation Programming Mode: Quasi-dynamic Group 3 | PHY initialization complete enable signal. Programming Mode: Quasi-dynamic Group 3 | PHY initialization complete enable signal. When asserted the dfi_init_complete signal can be used to trigger SDRAM initialisation Programming Mode: Quasi-dynamic Group 3

| PHY_DBI_MODE

 |  | DBI implemented in DDRC or PHY.    Present only in designs configured to support DDR4 and LPDDR4. Programming Mode: Static | DBI implemented in DDRC or PHY.   - 0 - DDRC implements DBI functionality.   - 1 - PHY implements DBI functionality.   Present only in designs configured to support DDR4 and LPDDR4. Programming Mode: Static

| DIS_DYN_ADR_TRI

 |  | Sets PHY specific Dynamic Tristating. This functionality works only in DFI 1:2 frequency ratio mode regardless of MSTR.en_2t_timing_mode, so if either of the following condition is met no special IDLE command is issued on the DFI bus:  - MEMC_FREQ_RATIO==1  - MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1 The special IDLE command means the following codes with the case where all the dfi_cs is 1:  - (phase 0 and 1) dfi_ras_n=1  - (phase 0 and 1) dfi_cas_n= 1  - phase 0 and 1) dfi_we_n= 1  - (phase 0 and 1) dfi_bank [0]= 0  - (phase 0 and 1) dfi_act_n= 1 Programming Mode: Quasi-dynamic Group 3 | 

|===


=== DFITMG0 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DFI_T_CTRL_DELAY

 | Specifies the number of DFI clock cycles after an assertion or deassertion of the DFI control signals that the control signals at the PHY-DRAM interface reflect the assertion or deassertion. If the DFI clock and the memory clock are not phase-aligned, this timing parameter must be rounded up to the next integer value. Note that if using RDIMM/LRDIMM, it is necessary to increment this parameter by RDIMM's/LRDIMM's extra cycle of latency in terms of DFI clock. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4 | Specifies the number of DFI clock cycles after an assertion or de-assertion of the DFI control signals that the control signals at the PHY-DRAM interface reflect the assertion or de-assertion. If the DFI clock and the memory clock are not phase-aligned, this timing parameter must be rounded up to the next integer value. Note that if using RDIMM/LRDIMM, it is necessary to increment this parameter by RDIMM's/LRDIMM's extra cycle of latency in terms of DFI clock. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4 | Specifies the number of DFI clock cycles after an assertion or deassertion of the DFI control signals that the control signals at the PHY-DRAM interface reflect the assertion or deassertion. If the DFI clock and the memory clock are not phase-aligned, this timing parameter should be rounded up to the next integer value. Note that if using RDIMM/LRDIMM, it is necessary to increment this parameter by RDIMM's/LRDIMM's extra cycle of latency in terms of DFI clock. Programming Mode: Quasi-dynamic Group 4

| DFI_RDDATA_USE_DFI_PHY_CLK

 | Defines whether dfi_rddata_en/dfi_rddata/dfi_rddata_valid is generated using HDR (DFI clock) or SDR (DFI PHY clock) values. Selects whether value in DFITMG0.dfi_t_rddata_en is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles:  - 0 in terms of HDR (DFI clock) cycles  - 1 in terms of SDR (DFI PHY clock) cycles Refer to PHY specification for correct value. If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:  - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field must be set to 0  - Else, it must be set to 1  Programming Mode: Static | Defines whether dfi_rddata_en/dfi_rddata/dfi_rddata_valid is generated using HDR (DFI clock) or SDR (DFI PHY clock) values. Selects whether value in DFITMG0.dfi_t_rddata_en is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles.    Refer to PHY specification for correct value. If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:  - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field must be set to 0  - Else, it must be set to 1  Programming Mode: Static | Defines whether dfi_rddata_en/dfi_rddata/dfi_rddata_valid is generated using HDR (DFI clock) or SDR (DFI PHY clock) values.   Selects whether value in DFITMG0.dfi_t_rddata_en is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles:  - 0 in terms of HDR (DFI clock) cycles  - 1 in terms of SDR (DFI PHY clock) cycles Refer to PHY specification for correct value. If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:  - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field should be set to 0  - Else, it must be set to 1  Programming Mode: Static

| DFI_T_RDDATA_EN

 2+| Time from the assertion of a read command on the DFI interface to the assertion of the dfi_rddata_en signal. Refer to PHY specification for correct value. This corresponds to the DFI parameter trddata_en. Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of trddata_en. This is to compensate for the extra cycles of latency through the RDIMM/LRDIMM. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_rddata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 1, Group 4 | Time from the assertion of a read command on the DFI interface to the assertion of the dfi_rddata_en signal. Refer to PHY specification for correct value. This corresponds to the DFI parameter trddata_en. Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of trddata_en. This is to compensate for the extra cycle(s) of latency through the RDIMM/LRDIMM. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_rddata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 1 and Group 4

| DFI_WRDATA_USE_DFI_PHY_CLK

 | Defines whether dfi_wrdata_en/dfi_wrdata/dfi_wrdata_mask is generated using HDR (DFI clock) or SDR (DFI PHY clock) values. Selects whether value in DFITMG0.dfi_tphy_wrlat is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles. Selects whether value in DFITMG0.dfi_tphy_wrdata is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles.  - 0 in terms of HDR (DFI clock) cycles  - 1 in terms of SDR (DFI PHY clock) cycles Refer to PHY specification for correct value. If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:  - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field must be set to 0  - Else, it must be set to 1  Programming Mode: Static | Defines whether dfi_wrdata_en/dfi_wrdata/dfi_wrdata_mask is generated using HDR (DFI clock) or SDR (DFI PHY clock) values. Selects whether value in DFITMG0.dfi_tphy_wrlat is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles. Selects whether value in DFITMG0.dfi_tphy_wrdata is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles.    Refer to PHY specification for correct value.   If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:  - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field must be set to 0  - Else, it must be set to 1  Programming Mode: Static | Defines whether dfi_wrdata_en/dfi_wrdata/dfi_wrdata_mask is generated using HDR (DFI clock) or SDR (DFI PHY clock) values Selects whether value in DFITMG0.dfi_tphy_wrlat  is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles Selects whether value in DFITMG0.dfi_tphy_wrdata is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles  - 0 in terms of HDR (DFI clock) cycles  - 1 in terms of SDR (DFI PHY clock) cycles Refer to PHY specification for correct value. If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:  - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field should be set to 0  - Else, it must be set to 1  Programming Mode: Static

| DFI_TPHY_WRDATA

 2+| Specifies the number of clock cycles between when dfi_wrdata_en is asserted to when the associated write data is driven on the dfi_wrdata signal. This corresponds to the DFI timing parameter tphy_wrdata. For more information on correct value, see PHY specification. Note, maximum supported value is 8. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_wrdata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 4 | Specifies the number of clock cycles between when dfi_wrdata_en is asserted to when the associated write data is driven on the dfi_wrdata signal.  This corresponds to the DFI timing parameter tphy_wrdata.  Refer to PHY specification for correct value. Note, max supported value is 8. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_wrdata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 4

| DFI_TPHY_WRLAT

 2+| Write latency. Number of clocks from the write command to write data enable (dfi_wrdata_en). This corresponds to the DFI timing parameter tphy_wrlat. Refer to PHY specification for correct value.Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of tphy_wrlat. This is to compensate for the extra cycles of latency through the RDIMM/LRDIMM. For LPDDR4, dfi_tphy_wrlat&gt;60 is not supported. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_wrdata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 2, Group 4 | Write latency Number of clocks from the write command to write data enable (dfi_wrdata_en).  This corresponds to the DFI timing parameter tphy_wrlat. Refer to PHY specification for correct value.Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of tphy_wrlat. This is to compensate for the extra cycle(s) of latency through the RDIMM/LRDIMM. For LPDDR4, dfi_tphy_wrlat&gt;60 is not supported. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_wrdata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 1 and Group 4

|===


=== DFITMG1 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DFI_T_PARIN_LAT

 2+| Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is asserted and when the associated dfi_parity_in signal is driven. Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 4 | Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is asserted and when the associated dfi_parity_in signal is driven. Programming Mode: Quasi-dynamic Group 4

| DFI_T_WRDATA_DELAY

 2+| Specifies the number of DFI clock cycles between when the dfi_wrdata_en signal is asserted and when the corresponding write data transfer is completed on the DRAM bus. This corresponds to the DFI timing parameter twrdata_delay. For more information on correct value, see PHY specification. For DFI 3.0 PHY, set to twrdata_delay, a new timing parameter introduced in DFI 3.0. For DFI 2.1 PHY, set to tphy_wrdata + (delay of DFI write data to the DRAM). Value to be programmed is in terms of DFI clocks, not PHY clocks. In FREQ_RATIO=2, divide PHY's value by 2 and round up to next integer. If using DFITMG0.dfi_wrdata_use_dfi_phy_clk=1, add 1 to the value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4 | Specifies the number of DFI clock cycles between when the dfi_wrdata_en signal is asserted and when the corresponding write data transfer is completed on the DRAM bus.  This corresponds to the DFI timing parameter twrdata_delay.  Refer to PHY specification for correct value.  For DFI 3.0 PHY, set to twrdata_delay, a new timing parameter introduced in DFI 3.0. For DFI 2.1 PHY, set to tphy_wrdata + (delay of DFI write data to the DRAM).  Value to be programmed is in terms of DFI clocks, not PHY clocks. In FREQ_RATIO=2, divide PHY's value by 2 and round up to next integer. If using DFITMG0.dfi_wrdata_use_dfi_phy_clk=1, add 1 to the value. Unit: Clocks Programming Mode: Quasi-dynamic Group 4

| DFI_T_DRAM_CLK_DISABLE

 2+| Specifies the number of DFI clock cycles from the assertion of the dfi_dram_clk_disable signal on the DFI until the clock to the DRAM memory devices, at the PHY-DRAM boundary, maintains a low value. If the DFI clock and the memory clock are not phase aligned, this timing parameter must be rounded up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4 | Specifies the number of DFI clock cycles from the assertion of the dfi_dram_clk_disable signal on the DFI until the clock to the DRAM memory devices, at the PHY-DRAM boundary, maintains a low value. If the DFI clock and the memory clock are not phase aligned, this timing parameter should be rounded up to the next integer value. Programming Mode: Quasi-dynamic Group 4

| DFI_T_DRAM_CLK_ENABLE

 | Specifies the number of DFI clock cycles from the deassertion of the dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the clock to the DRAM memory devices, at the PHY-DRAM boundary. If the DFI clock and the memory clock are not phase aligned, this timing parameter must be rounded up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4 | Specifies the number of DFI clock cycles from the de-assertion of the dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the clock to the DRAM memory devices, at the PHY-DRAM boundary. If the DFI clock and the memory clock are not phase aligned, this timing parameter must be rounded up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4 | Specifies the number of DFI clock cycles from the deassertion of the dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the clock to the DRAM memory devices, at the PHY-DRAM boundary. If the DFI clock and the memory clock are not phase aligned, this timing parameter should be rounded up to the next integer value. Programming Mode: Quasi-dynamic Group 4

| DFI_T_CMD_LAT

 |  | Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is asserted and when the associated command is driven. This field is used for CAL mode, must be set to '0' or tCAL, which matches the CAL mode register setting in the DRAM. When enabling CAL mode with RDIMM/LRDIMM, this field must be set to tCAL-CLA (Command Latency Adder). For more information on CLA, see JEDEC DDR4 Register Specification. If the PHY can add the latency for CAL mode, this must be set to '0'. Valid Range: 0 to 8. Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is asserted and when the associated command is driven. This field is used for CAL mode, should be set to '0' or the value which matches the CAL mode register setting in the DRAM.  If the PHY can add the latency for CAL mode, this should be set to '0'. Valid Range: 0, 3, 4, 5, 6, and 8 Programming Mode: Quasi-dynamic Group 2 and Group 4

|===


=== DFIUPD0 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DIS_AUTO_CTRLUPD

 | When '1', disable the automatic dfi_ctrlupd_req generation by the uMCTL2. The controller must issue the dfi_ctrlupd_req signal using register DBGCMD.ctrlupd. When '0', uMCTL2 issues dfi_ctrlupd_req periodically. Programming Mode: Quasi-dynamic Group 3 | Sets the automatic dfi_ctrlupd_req generation by the uMCTL2. The controller must issue the dfi_ctrlupd_req signal using register DBGCMD.ctrlupd.  Programming Mode: Quasi-dynamic Group 3 | When '1', disable the automatic dfi_ctrlupd_req generation by the uMCTL2. The core must issue the dfi_ctrlupd_req signal using register DBGCMD.ctrlupd. When '0', uMCTL2 issues dfi_ctrlupd_req periodically. Programming Mode: Quasi-dynamic Group 3

| DIS_AUTO_CTRLUPD_SRX

 | When '1', disable the automatic dfi_ctrlupd_req generation by the uMCTL2 at self-refresh exit. When '0', uMCTL2 issues a dfi_ctrlupd_req before or after exiting self-refresh, depending on DFIUPD0.ctrlupd_pre_srx. Programming Mode: Static | Sets the automatic dfi_ctrlupd_req generation by the uMCTL2 at self-refresh exit. Programming Mode: Static | When '1', disable the automatic dfi_ctrlupd_req generation by the uMCTL2 at self-refresh exit. When '0', uMCTL2 issues a dfi_ctrlupd_req before or after exiting self-refresh,  depending on DFIUPD0.ctrlupd_pre_srx. Programming Mode: Static

| CTRLUPD_PRE_SRX

 | Selects dfi_ctrlupd_req requirements at SRX:  - 0 - Send ctrlupd after SRX  - 1 - Send ctrlupd before SRX     If DFIUPD0.dis_auto_ctrlupd_srx=1, this register has no impact, because no dfi_ctrlupd_req is issued when SRX.    For SNPS DDR32 PHY, keep the default value 0x0.  Programming Mode: Static | Selects dfi_ctrlupd_req requirements at SRX.    If DFIUPD0.dis_auto_ctrlupd_srx=1, this register has no impact, because no dfi_ctrlupd_req is issued when SRX. Programming Mode: Static | Selects dfi_ctrlupd_req requirements at SRX:   - 0 : send ctrlupd after SRX   - 1 : send ctrlupd before SRX   If DFIUPD0.dis_auto_ctrlupd_srx=1, this register has no impact, because no dfi_ctrlupd_req will be issued when SRX.  Programming Mode: Static

| DFI_T_CTRLUP_MAX

 2+| Specifies the maximum number of DFI clock cycles that the dfi_ctrlupd_req signal can assert. Lowest value to assign to this variable is 0x40. Unit: DFI clock cycles. Programming Mode: Static | Specifies the maximum number of DFI clock cycles that the dfi_ctrlupd_req signal can assert. Lowest value to assign to this variable is 0x40. Programming Mode: Static

| DFI_T_CTRLUP_MIN

 | Specifies the minimum number of DFI clock cycles that the dfi_ctrlupd_req signal must be asserted. The uMCTL2 expects the PHY to respond within this time. If the PHY does not respond, the uMCTL2 deasserts dfi_ctrlupd_req after dfi_t_ctrlup_min + 2 cycles. Lowest value to assign to this variable is 0x1. Unit: DFI clock cycles. Programming Mode: Static | Specifies the minimum number of DFI clock cycles that the dfi_ctrlupd_req signal must be asserted. The uMCTL2 expects the PHY to respond within this time. If the PHY does not respond, the uMCTL2 de-asserts dfi_ctrlupd_req after dfi_t_ctrlup_min + 2 cycles. Lowest value to assign to this variable is 0x1. Unit: DFI clock cycles. Programming Mode: Static | Specifies the minimum number of DFI clock cycles that the dfi_ctrlupd_req signal must be asserted. The uMCTL2 expects the PHY to respond within this time.  If the PHY does not respond, the uMCTL2 will deassert dfi_ctrlupd_req after dfi_t_ctrlup_min + 2 cycles.  Lowest value to assign to this variable is 0x3. Programming Mode: Static

|===


=== DFIUPD1 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DFI_T_CTRLUPD_INTERVAL_MIN_X1024

 2+| This is the minimum amount of time between uMCTL2 initiated DFI update requests (which is executed whenever the uMCTL2 is idle). Set this number higher to reduce the frequency of update requests, which can have a small impact on the latency of the first read request when the uMCTL2 is idle. The minimum allowed value for this field is 1. Unit: Multiples of 1024 DFI clock cycles. For more information on how to program this register field, see "Note 1" in the "Notes on Timing Registers" section. Programming Mode: Static | This is the minimum amount of time between uMCTL2 initiated DFI update requests (which is executed whenever the uMCTL2 is idle). Set this number higher to reduce the frequency of update requests, which can have a small impact on the latency of the first read request when the uMCTL2 is idle. Minimum allowed value for this field is 1. Unit: 1024 DFI clock cycles Programming Mode: Static

| DFI_T_CTRLUPD_INTERVAL_MAX_X1024

 2+| This is the maximum amount of time between uMCTL2 initiated DFI update requests. This timer resets with each update request; when the timer expires dfi_ctrlupd_req is sent and traffic is blocked until the dfi_ctrlupd_ackx is received. PHY can use this idle time to recalibrate the delay lines to the DLLs. The DFI controller update is also used to reset PHY FIFO pointers in case of data capture errors. Updates are required to maintain calibration over PVT, but frequent updates may impact performance. Minimum allowed value for this field is 1. Note: Value programmed for DFIUPD1.dfi_t_ctrlupd_interval_max_x1024 must be greater than DFIUPD1.dfi_t_ctrlupd_interval_min_x1024. Unit: Multiples of 1024 DFI clock cycles. For more information on how to program this register field, see "Note 1" in the "Notes on Timing Registers" section. Programming Mode: Static | This is the maximum amount of time between uMCTL2 initiated DFI update requests. This timer resets with each update request; when the timer expires dfi_ctrlupd_req is sent and traffic is blocked until the dfi_ctrlupd_ackx is received. PHY can use this idle time to recalibrate the delay lines to the DLLs. The DFI controller update is also used to reset PHY FIFO pointers in case of data capture errors. Updates are required to maintain calibration over PVT, but frequent updates may impact performance. Minimum allowed value for this field is 1. Note: Value programmed for DFIUPD1.dfi_t_ctrlupd_interval_max_x1024 must be greater than DFIUPD1.dfi_t_ctrlupd_interval_min_x1024. Unit: 1024 DFI clock cycles Programming Mode: Static

|===


=== DRAMTMG0 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| WR2PRE

 2+| Specifies the minimum time between write and precharge to same bank. Specifications: WL + BL/2 + tWR = approximately 8 cycles + 15 ns = 14 clocks @400MHz and less for lower frequencies. where:  - WL: Write latency  - BL: Burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM. BST (burst terminate) is not supported at present  - tWR: Write recovery time. This comes directly from the SDRAM specification Add one extra cycle for LPDDR2/LPDDR3/LPDDR4 for this parameter. When the controller is operating in 1:2 frequency ratio mode, 1T mode, divide the previous value by 2. No rounding up. When the controller is operating in 1:2 frequency ratio mode, 2T mode, geardown mode or LPDDR4 mode, divide the previous value by 2 and round it up to the next integer value. Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency through the LRDIMM. For DDR4, LPDDR4, LPDDR3, using nWR(WR) instead of tWR to calculate the value of this parameter. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 |  Minimum time between write and precharge to same bank.   Unit: Clocks Specifications: WL + BL/2 + tWR = approximately 8 cycles + 15 ns = 14 clocks @400MHz and less for lower frequencies where:  - WL = write latency  - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM. BST (burst terminate) is not supported at present.  - tWR = Write recovery time. This comes directly from the SDRAM specification.  Add one extra cycle for LPDDR2/LPDDR3/LPDDR4 for this parameter. When the controller is operating in 1:2 frequency ratio mode, 1T mode, divide the above value by 2. No rounding up. When the controller is operating in 1:2 frequency ratio mode, 2T mode or LPDDR4 mode, divide the above value by 2 and round it up to the next integer value.  Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency through the LRDIMM. Programming Mode: Quasi-dynamic Group 1 and Group 2 and Group 4

| T_FAW

 2+| tFAW - valid only when 8 or more banks(or banks x bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | tFAW Valid only when 8 or more banks(or banks x bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: Clocks Programming Mode: Quasi-dynamic Group 2 and Group 4

| T_RAS_MAX

 2+| tRAS(max) - Specifies the maximum time between activate and precharge to same bank. This is the maximum time that a page can be kept open Minimum value of this register is 1. Zero is invalid. When the controller is operating in 1:1 frequency ratio mode, t_ras_max must be set to RoundDown(tRAS(max)/tCK/1024). When the controller is operating in 1:2 frequency ratio mode, t_ras_max must be set to RoundDown((RoundDown(tRAS(max)/tCK/1024)-1)/2). Unit: Multiples of 1024 DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | tRAS(max):  Maximum time between activate and precharge to same bank. This is the maximum time that a page can be kept open Minimum value of this register is 1. Zero is invalid. When the controller is operating in 1:2 frequency ratio mode, program this to (tRAS(max)-1)/2. No rounding up.  Unit: Multiples of 1024 clocks. Programming Mode: Quasi-dynamic Group 2 and Group 4

| T_RAS_MIN

 2+| tRAS(min) - Specifies the minimum time between activate and precharge to the same bank. When the controller is operating in 1:1 frequency ratio mode, t_ras_min must be set to RoundUp(tRASmin/tCK) When the controller is operating in 1:2 frequency ratio mode, 1T mode, t_ras_min must be set to RoundDown(RoundUp(tRASmin/tCK)/2) When the controller is operating in 1:2 frequency ratio mode, 2T mode, geardown mode or LPDDR4 mode, t_ras min must be set to RoundUp(RoundUp(tRASmin/tCK)/2) Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | tRAS(min):  Minimum time between activate and precharge to the same bank. When the controller is operating in 1:2 frequency mode, 1T mode, program this to tRAS(min)/2. No rounding up. When the controller is operating in 1:2 frequency ratio mode, 2T mode or LPDDR4 mode, program this to (tRAS(min)/2) and round it up to the next integer value. Unit: Clocks Programming Mode: Quasi-dynamic Group 2 and Group 4

|===


=== DRAMTMG1 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| T_XP

 2+| tXP - Specifies the minimum time after power-down exit to any operation. For DDR3, this must be programmed to tXPDLL if slow powerdown exit is selected in MR0[12].  If C/A parity for DDR4 is used, set to (tXP+PL) instead.  If LPDDR4 is selected and its spec has tCKELPD parameter, set to the larger of tXP and tCKELPD instead. When the controller is operating in 1:2 frequency ratio mode, program this to (tXP/2) and round it up to the next integer value. Units: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | tXP: Minimum time after power-down exit to any operation.  For DDR3, this should be programmed to tXPDLL if slow powerdown exit is selected in MR0[12].   If C/A parity for DDR4 is used, set to (tXP+PL) instead.  If LPDDR4 is selected and its spec has tCKELPD parameter, set to the larger of tXP and tCKELPD instead. When the controller is operating in 1:2 frequency ratio mode, program this to (tXP/2) and round it up to the next integer value. Units: Clocks Programming Mode: Quasi-dynamic Group 2 and Group 4

| RD2PRE

 2+| tRTP - Specifies the minimum time from read to precharge of same bank.  - DDR2 - tAL + BL/2 + max(RoundUp(tRTP/tCK), 2) - 2  - DDR3 - tAL + max (RoundUp(tRTP/tCK), 4)  - DDR4 - Max of following two equations:  tAL + max (RoundUp(tRTP/tCK), 4) or, RL + BL/2 - tRP (*).  - mDDR - BL/2  - LPDDR2 - Depends on if it is LPDDR2-S2 or LPDDR2-S4: LPDDR2-S2: BL/2 + RoundUp(tRTP/tCK) - 1. LPDDR2-S4: BL/2 + max(RoundUp(tRTP/tCK),2) - 2.  - LPDDR3 - BL/2 + max(RoundUp(tRTP/tCK),4) - 4  - LPDDR4 - BL/2 + max(RoundUp(tRTP/tCK),8) - 8 (*) When both DDR4 SDRAM and ST-MRAM are used simultaneously, use SDRAM's tRP value for calculation. When the controller is operating in 1:2 mode, 1T mode, divide the previous value by 2. No rounding up.  When the controller is operating in 1:2 mode, 2T mode, geardown mode or LPDDR4 mode, divide the previous value by 2 and round it up to the next integer value. For DDR4, using RTP instead of tRTP to calculate the value of this parameter. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 | tRTP:  Minimum time from read to precharge of same bank.  - DDR2: tAL + BL/2 + max(tRTP, 2) - 2  - DDR3: tAL + max (tRTP, 4)  - DDR4: Max of following two equations:            tAL + max (tRTP, 4) or,             RL + BL/2 - tRP (*).  - mDDR: BL/2  - LPDDR2: Depends on if it's LPDDR2-S2 or LPDDR2-S4:            LPDDR2-S2: BL/2 + tRTP - 1.            LPDDR2-S4: BL/2 + max(tRTP,2) - 2.  - LPDDR3: BL/2 +  max(tRTP,4) - 4  - LPDDR4: BL/2 + max(tRTP,8) - 8 (*) When both DDR4 SDRAM and ST-MRAM are used simultaneously, use SDRAM's tRP value for calculation.  When the controller is operating in 1:2 mode, 1T mode, divide the above value by 2. No rounding up.  When the controller is operating in 1:2 mode, 2T mode or LPDDR4 mode, divide the above value by 2 and round it up to the next integer value.  Unit: Clocks. Programming Mode: Quasi-dynamic Group 1 and Group 2 and Group 4

| T_RC

 2+| tRC - Specifies the minimum time between activates to same bank. When the controller is operating in 1:2 frequency ratio mode, program this to (tRC/2) and round up to next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | tRC:  Minimum time between activates to same bank. When the controller is operating in 1:2 frequency ratio mode, program this to (tRC/2) and round up to next integer value. Unit: Clocks. Programming Mode: Quasi-dynamic Group 2 and Group 4

|===


=== DRAMTMG12 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| T_MRD_PDA

 |  | tMRD_PDA: This is the Mode Register Set command cycle time in PDA mode. When the controller is operating in 1:2 frequency ratio mode, program this to (tMRD_PDA/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | tMRD_PDA:  This is the Mode Register Set command cycle time in PDA mode. When the controller is operating in 1:2 frequency ratio mode, program this to (tMRD_PDA/2) and round it up to the next integer value. Programming Mode: Quasi-dynamic Group 2 and Group 4

| T_WR_MPR

 |  | This bit is used only in DDR4. Cycles between MPR Write and other command. Set this to tMOD + AL (or tMOD + PL + AL if C/A parity is also used).  When the controller is operating in 1:2 frequency ratio mode, program this to (tWR_MPR/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | 

|===


=== DRAMTMG2 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| RD2WR

 | Minimum time from read command to write command. This must include time for bus turnaround (both within ranks and between ranks) and all PHY and system requirements.  After the PHY has completed training, the value programmed may need to be increased.  See the relevant PHY databook for details of what should be included here.  The following calculations are minimum values, and do not include the PHY/system requirements mentioned above:  DDR2/3/mDDR: RL + BL/2 + 2 - WL  DDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL  LPDDR2/LPDDR3: RL + BL/2 + RU(tDQSCKmax/tCK) + 1 - WL  LPDDR4(DQ ODT is Disabled): RL + BL/2 + RU(tDQSCKmax/tCK) + WR_PREAMBLE + RD_POSTAMBLE - WL  LPDDR4(DQ ODT is Enabled): RL + BL/2 + RU(tDQSCKmax/tCK) + RD_POSTAMBLE - ODTLon - RU(tODTon(min)/tCK) + 1  Where:  - WL: Write latency  - BL: Burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - RL: Read latency = CAS latency  - WR_PREAMBLE: 1 (1tCK write preamble), 2 (2tCK write preamble). This is unique to DDR4 and LPDDR4  - RD_POSTAMBLE: 0.5 (0.5tCK read postamble), 1.5 (1.5tCK read postamble). This is unique to LPDDR4 For LPDDR2/LPDDR3/LPDDR4, if derating is enabled (DERATEEN.derate_enable=1), derated tDQSCKmax must be used.  When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the previous equation by 2, and round it up to next integer.  Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency through the LRDIMM. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 | Minimum time from read command to write command. This must include time for bus turnaround (both within ranks and between ranks) and all PHY and system requirements.  After the PHY has completed training, the value programmed may need to be increased.  Please see the relevant PHY databook for details of what should be included here.  The following calculations are minimum values, and do not include the PHY/system requirements mentioned above:  DDR2/3/mDDR: RL + BL/2 + 2 - WL  DDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL  LPDDR2/LPDDR3: RL + BL/2 + RU(tDQSCKmax/tCK) + 1 - WL  LPDDR4(DQ ODT is Disabled): RL + BL/2 + RU(tDQSCKmax/tCK) + WR_PREAMBLE + RD_POSTAMBLE - WL  LPDDR4(DQ ODT is Enabled): RL + BL/2 + RU(tDQSCKmax/tCK) + RD_POSTAMBLE - ODTLon - RD(tODTon(min)/tCK) + 1  Where:  - WL: Write latency  - BL: Burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - RL: Read latency = CAS latency  - WR_PREAMBLE: 1 (1tCK write preamble), 2 (2tCK write preamble). This is unique to DDR4 and LPDDR4  - RD_POSTAMBLE: 0.5 (0.5tCK read postamble), 1.5 (1.5tCK read postamble). This is unique to LPDDR4 For LPDDR2/LPDDR3/LPDDR4, if derating is enabled (DERATEEN.derate_enable=1), derated tDQSCKmax must be used.  When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the previous equation by 2, and round it up to next integer.  Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency through the LRDIMM. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 |   DDR2/3/mDDR: RL + BL/2 + 2 - WL  DDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL  LPDDR2/LPDDR3: RL + BL/2 + RU(tDQSCKmax/tCK) + 1 - WL  LPDDR4(DQ ODT is Disabled): RL + BL/2 + RU(tDQSCKmax/tCK) + WR_PREAMBLE + RD_POSTAMBLE - WL  LPDDR4(DQ ODT is Enabled) : RL + BL/2 + RU(tDQSCKmax/tCK) + RD_POSTAMBLE - ODTLon - RU(tODTon(min)/tCK)  Minimum time from read command to write command. Include time for bus turnaround and all per-bank, per-rank, and global constraints.  See the relevant PHY databook for details of what should be included here. Unit: Clocks. Where:  - WL = write latency  - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - RL = read latency = CAS latency  - WR_PREAMBLE = write preamble. This is unique to DDR4 and LPDDR4.  - RD_POSTAMBLE = read postamble. This is unique to LPDDR4. For LPDDR2/LPDDR3/LPDDR4, if derating is enabled (DERATEEN.derate_enable=1), derated tDQSCKmax should be used.  When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the above equation by 2, and round it up to next integer.  Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency through the LRDIMM. Programming Mode: Quasi-dynamic Group 1 and Group 2 and Group 4

| WR2RD

 | In DDR4, minimum time from write command to read command for same bank group. In other protoocls, minimum time from write command to read command.  This must include time for bus turn-around and all PHY and system requirements.  After the PHY has completed training, the value programmed may need to be increased.  See the relevant PHY databook for details of what should be included here.  The following calculations are minimum values, and do not include the PHY/system requirements mentioned above:  DDR4: CWL + PL + BL/2 + tWTR_L  LPDDR2/3/4: WL + BL/2 + tWTR + 1  Others: CWL + BL/2 + tWTR  Where:  - CWL: CAS write latency  - WL: Write latency  - PL: Parity latency  - BL: Burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - tWTR_L: Internal write to read command delay for same bank group. This comes directly from the SDRAM specification   - tWTR: Internal write to read command delay. This comes directly from the SDRAM specification Add one extra cycle for LPDDR2/LPDDR3/LPDDR4 operation.  WTR_L must be increased by one if DDR4 2tCK write preamble is used.  When the controller is operating in 1:2 mode, divide the value calculated using the previous equation by 2, and round it up to next integer.  If your configuration has RANKCTL1.wr2rd_dr, write to read bus turn-around between different physical ranks are controlled by RANKCTL1.wr2rd_dr.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 | In DDR4, minimum time from write command to read command for same bank group. In other protoocls, minimum time from write command to read command.  This must include time for bus turn-around and all PHY and system requirements.  After the PHY has completed training, the value programmed may need to be increased.  Please see the relevant PHY databook for details of what should be included here.  The following calculations are minimum values, and do not include the PHY/system requirements mentioned above:  DDR4: CWL + BL/2 + tWTR_L  LPDDR2/3/4: WL + BL/2 + tWTR + 1  Others: CWL + BL/2 + tWTR  Where:  - CWL: CAS write latency  - WL: Write latency  - BL: Burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - tWTR_L: Internal write to read command delay for same bank group. This comes directly from the SDRAM specification   - tWTR: Internal write to read command delay. This comes directly from the SDRAM specification Add one extra cycle for LPDDR2/LPDDR3/LPDDR4 operation.  WTR_L must be increased by one if DDR4 2tCK write preamble is used.  When the controller is operating in 1:2 mode, divide the value calculated using the previous equation by 2, and round it up to next integer.  If your configuration has RANKCTL1.wr2rd_dr, write to read bus turn-around between different physical ranks are controlled by RANKCTL1.wr2rd_dr.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 |  DDR4: CWL + PL + BL/2 + tWTR_L LPDDR2/3/4: WL + BL/2 + tWTR + 1 Others: CWL + BL/2 + tWTR In DDR4, minimum time from write command to read command for same bank group. In others, minimum time from write command to read command. Includes time for bus turnaround, recovery times, and all per-bank, per-rank, and global constraints.   Unit: Clocks. Where:  - CWL = CAS write latency  - WL = Write latency  - PL = Parity latency  - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - tWTR_L = internal write to read command delay for same bank group. This comes directly from the SDRAM specification.   - tWTR = internal write to read command delay. This comes directly from the SDRAM specification.  Add one extra cycle for LPDDR2/LPDDR3/LPDDR4 operation.  When the controller is operating in 1:2 mode, divide the value calculated using the above equation by 2, and round it up to next integer. Programming Mode: Quasi-dynamic Group 1 and Group 2 and Group 4

| READ_LATENCY

 |  | Set this field to RL. Indicates the time from read command to read data on SDRAM interface. This must be set to RL. Note that, depending on the PHY, if using RDIMM/LRDIMM, it might be necessary to adjust the value of RL to compensate for the extra cycle of latency through the RDIMM/LRDIMM. When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the previous equation by 2, and round it up to next integer. This register field is not required for DDR2 and DDR3, as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols For all protocols, in addition to programming this register field, it is necessary to program DFITMG0 and DFITMG1 to control the read and write latencies Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 | Set to RL Time from read command to read data on SDRAM interface. This must be set to RL. Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to adjust the value of RL to compensate for the extra cycle of latency through the RDIMM/LRDIMM. When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the above equation by 2, and round it up to next integer. This register field is not required for DDR2 and DDR3 (except if MEMC_TRAINING is set), as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols Unit: clocks Programming Mode: Quasi-dynamic Group 1 and Group 2 and Group 4

| WRITE_LATENCY

 |  | Set this field to WL. Indicates the Time from write command to write data on SDRAM interface. This must be set to WL. For mDDR, it must  be set to 1. Note that, depending on the PHY, if using RDIMM/LRDIMM, it might be necessary to adjust the value of WL to compensate for the extra cycle of latency through the RDIMM/LRDIMM. When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the previous equation by 2, and round it up to next integer. This register field is not required for DDR2 and DDR3, as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols For all protocols, in addition to programming this register field, it is necessary to program DFITMG0 and DFITMG1 to control the read and write latencies Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 | Set to WL Time from write command to write data on SDRAM interface. This must be set to WL. For mDDR, it should normally be set to 1. Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to adjust the value of WL to compensate for the extra cycle of latency through the RDIMM/LRDIMM. When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the above equation by 2, and round it up to next integer. This register field is not required for DDR2 and DDR3 (except if MEMC_TRAINING is set), as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols Unit: clocks Programming Mode: Quasi-dynamic Group 1 and Group 2 and Group 4

|===


=== DRAMTMG3 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| T_MRD

 2+| tMRD- Indicates the number of cycles to wait after a mode register write or read. Depending on the connected SDRAM, tMRD represents:  - DDR2/mDDR: Time from MRS to any command  - DDR3/4: Time from MRS to MRS command  - LPDDR2: not used  - LPDDR3/4: Time from MRS to non-MRS command  When the controller is operating in 1:2 frequency ratio mode, program this to (tMRD/2) and round it up to the next integer value. If C/A parity for DDR4 is used, set to tMRD_PAR(tMOD+PL) instead. If CAL mode is enabled (DFITMG1.dfi_t_cmd_lat &gt; 0), tCAL (=DFITMG1.dfi_cmd_lat) must be added to the previous calculations. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | tMRD: Cycles to wait after a mode register write or read. Depending on the connected SDRAM, tMRD represents: DDR2/mDDR: Time from MRS to any command DDR3/4: Time from MRS to MRS command LPDDR2: not used LPDDR3/4: Time from MRS to non-MRS command. When the controller is operating in 1:2 frequency ratio mode, program this to (tMRD/2) and round it up to the next integer value. If C/A parity for DDR4 is used, set to tMRD_PAR(tMOD+PL) instead. Programming Mode: Quasi-dynamic Group 2 and Group 4

| T_MOD

 | tMOD - Parameter used only in DDR3 and DDR4. Indicates the number of cycles between load mode command and following non-load mode command. If C/A parity for DDR4 is used, set to tMOD_PAR(tMOD+PL) instead. If CAL mode is enabled (DFITMG1.dfi_t_cmd_lat &gt; 0), tCAL (=DFITMG1.dfi_cmd_lat) must be added to the previous calculations. Set to tMOD if controller is operating in 1:1 frequency ratio mode, or tMOD/2 (rounded up to next integer) if controller is operating in 1:2 frequency ratio mode. Note that if using RDIMM/LRDIMM, depending on the PHY, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency applied to mode register writes by the RDIMM/LRDIMM chip. Also note that if using RDIMM or LRDIMM, the minimum value of this register is tMRD_L2 if controller is operating in 1:1 frequency ratio mode, or tMRD_L2/2 (rounded up to next integer) if controller is operating in 1:2 frequency ratio mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | tMOD - Parameter used only in DDR3 and DDR4. Indicates the number of cycles between load mode command and following non-load mode command. If C/A parity for DDR4 is used, set to tMOD_PAR(tMOD+PL) instead. If CAL mode is enabled (DFITMG1.dfi_t_cmd_lat &gt; 0), tCAL (=DFITMG1.dfi_cmd_lat) must be added to the previous calculations. Set to tMOD if controller is operating in 1:1 frequency ratio mode, or tMOD/2 (rounded up to next integer) if controller is operating in 1:2 frequency ratio mode. Note that if using RDIMM/LRDIMM, depending on the PHY, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency applied to mode register writes by the RDIMM/LRDIMM chip. Also note that if using LRDIMM, the minimum value of this register is tMRD_L2 if controller is operating in 1:1 frequency ratio mode, or tMRD_L2/2 (rounded up to next integer) if controller is operating in 1:2 frequency ratio mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | tMOD: Parameter used only in DDR3 and DDR4. Cycles between load mode command and following non-load mode command. If C/A parity for DDR4 is used, set to tMOD_PAR(tMOD+PL) instead. If MPR writes for DDR4 are used, set to tMOD + AL (or tMPD_PAR + AL if C/A parity is also used). Set to tMOD if controller is operating in 1:1 frequency ratio mode, or tMOD/2 (rounded up to next integer) if controller is operating in 1:2 frequency ratio mode. Note that if using RDIMM/LRDIMM, depending on the PHY, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency applied to mode register writes by the RDIMM/LRDIMM chip. Also note that if using LRDIMM, the minimum value of this register is tMRD_L2 if controller is operating in 1:1 frequency ratio mode, or tMRD_L2/2 (rounded up to next integer) if controller is operating in 1:2 frequency ratio mode. Programming Mode: Quasi-dynamic Group 2 and Group 4

| T_MRW

 2+|  | Time to wait after a mode register write or read (MRW or MRR). Present only in designs configured to support LPDDR2, LPDDR3 or LPDDR4. LPDDR2 typically requires value of 5. LPDDR3 typically requires value of 10. LPDDR4: Set this to the larger of tMRW and tMRWCKEL. For LPDDR2, this register is used for the time from a MRW/MRR to all other commands. When the controller is operating in 1:2 frequency ratio mode, program this to the above values divided by 2 and round it up to the next integer value. For LDPDR3, this register is used for the time from a MRW/MRR to a MRW/MRR. Programming Mode: Quasi-dynamic Group 2 and Group 4

|===


=== DRAMTMG4 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| T_RCD

 2+| tRCD - tAL: Indicates the minimum time from activate to read or write command to same bank. When the controller is operating in 1:2 frequency ratio mode, program this to ((tRCD - tAL)/2) and round it up to the next integer value.  Minimum value allowed for this register is 1, which implies minimum (tRCD - tAL) value to be 2 when the controller is operating in 1:2 frequency ratio mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 | tRCD - tAL: Minimum time from activate to read or write command to same bank. When the controller is operating in 1:2 frequency ratio mode, program this to ((tRCD - tAL)/2) and round it up to the next integer value.  Minimum value allowed for this register is 1, which implies minimum (tRCD - tAL) value to be 2 when the controller is operating in 1:2 frequency ratio mode.  Unit: Clocks. Programming Mode: Quasi-dynamic Group 1 and Group 2 and Group 4

| T_CCD

 2+| DDR4: tCCD_L: This is the minimum time between two reads or two writes for same bank group. Others: tCCD: This is the minimum time between two reads or two writes. When the controller is operating in 1:2 frequency ratio mode, program this to (tCCD_L/2 or tCCD/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | DDR4: tCCD_L: This is the minimum time between two reads or two writes for same bank group. Others: tCCD: This is the minimum time between two reads or two writes. When the controller is operating in 1:2 frequency ratio mode, program this to (tCCD_L/2 or tCCD/2) and round it up to the next integer value. Unit: clocks. Programming Mode: Quasi-dynamic Group 2 and Group 4

| T_RRD

 2+| DDR4: tRRD_L: This is the minimum time between activates from bank "a" to bank "b" for same bank group. Others: tRRD: Minimum time between activates from bank "a" to bank "b" When the controller is operating in 1:2 frequency ratio mode, program this to (tRRD_L/2 or tRRD/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | DDR4: tRRD_L: Minimum time between activates from bank "a" to bank "b" for same bank group. Others: tRRD: Minimum time between activates from bank "a" to bank "b" When the controller is operating in 1:2 frequency ratio mode, program this to (tRRD_L/2 or tRRD/2) and round it up to the next integer value. Unit: Clocks. Programming Mode: Quasi-dynamic Group 2 and Group 4

| T_RP

 2+| tRP: Indicates the minimum time from single-bank precharge to activate of same bank. When the controller is operating in 1:1 frequency ratio mode, t_rp must be set to RoundUp(tRP/tCK). When the controller is operating in 1:2 frequency ratio mode, t_rp must be set to RoundDown(RoundUp(tRP/tCK)/2) + 1. When the controller is operating in 1:2 frequency ratio mode in LPDDR4, t_rp must be set to RoundUp(RoundUp(tRP/tCK)/2). Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | tRP:  Minimum time from precharge to activate of same bank.      When the controller is operating in 1:1 frequency ratio mode, t_rp should be set to RoundUp(tRP/tCK).      When the controller is operating in 1:2 frequency ratio mode, t_rp should be set to RoundDown(RoundUp(tRP/tCK)/2) + 1.      When the controller is operating in 1:2 frequency ratio mode in LPDDR4, t_rp should be set to RoundUp(RoundUp(tRP/tCK)/2).       Unit: Clocks. Programming Mode: Quasi-dynamic Group 2 and Group 4

|===


=== DRAMTMG5 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| T_CKSRX

 2+| This is the time before self-refresh Exit that CK is maintained as a valid clock before issuing SRX. Specifies the clock stable time before SRX.  Recommended settings:  - mDDR - 1  - LPDDR2 - 2  - LPDDR3 - 2  - LPDDR4 - tCKCKEH  - DDR2 - 1   - DDR3 - tCKSRX   - DDR4 - tCKSRX  When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | This is the time before Self Refresh Exit that CK is maintained as a valid clock before issuing SRX. Specifies the clock stable time before SRX.       Recommended settings:     - mDDR: 1     - LPDDR2: 2     - LPDDR3: 2     - LPDDR4: tCKCKEH     - DDR2: 1       - DDR3: tCKSRX      - DDR4: tCKSRX  When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. Programming Mode: Quasi-dynamic Group 2 and Group 4

| T_CKSRE

 2+| This is the time after self-refresh Down Entry that CK is maintained as a valid clock. Specifies the clock disable delay after SRE.  Recommended settings:  - mDDR - 0  - LPDDR2 - 2  - LPDDR3 - 2  - LPDDR4 - tCKELCK  - DDR2 - 1   - DDR3 - Max (10 ns, 5 tCK)  - DDR4(No RDIMM) - Max (10 ns, 5 tCK) (+ PL(parity latency)(*))  - DDR4(RDIMM)    - Max (Max (10 ns, 5 tCK) (+ PL(parity latency)(*)), tCKOff) (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register must be increased by PL. When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | This is the time after Self Refresh Down Entry that CK is maintained as a valid clock. Specifies the clock disable delay after SRE.      Recommended settings:     - mDDR: 0     - LPDDR2: 2     - LPDDR3: 2     - LPDDR4: tCKELCK     - DDR2: 1      - DDR3: max (10 ns, 5 tCK)     - DDR4: max (10 ns, 5 tCK) (+ PL(parity latency)(*)) (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register should be increased by PL.  When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. Programming Mode: Quasi-dynamic Group 2 and Group 4

| T_CKESR

 2+| Indicates the minimum CKE low width for self-refresh or self-refresh power down entry to exit timing in memory clock cycles.  Recommended settings:  - mDDR - tRFC  - LPDDR2 - tCKESR  - LPDDR3 - tCKESR  - LPDDR4 - max(tCKE, tSR)  - DDR2 - tCKE   - DDR3 - tCKE + 1   - DDR4(No RDIMM) - tCKE + 1 (+ PL(parity latency)(*))  - DDR4(RDIMM)    - t_cksre + tCKEV (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register must be increased by PL. When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | Minimum CKE low width for Self refresh or Self refresh power down entry to exit timing in memory clock cycles.   Recommended settings:     - mDDR: tRFC     - LPDDR2: tCKESR     - LPDDR3: tCKESR     - LPDDR4: max(tCKE, tSR)     - DDR2: tCKE      - DDR3: tCKE + 1       - DDR4: tCKE + 1 (+ PL(parity latency)(*))  (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register should be increased by PL.  When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. Programming Mode: Quasi-dynamic Group 2 and Group 4

| T_CKE

 2+| Indicates the minimum number of cycles of CKE HIGH/LOW during power-down and self-refresh.  - LPDDR2/LPDDR3 mode - Set this to the larger of tCKE or tCKESR  - LPDDR4 mode - Set this to the larger of tCKE or tSR  - Non-LPDDR2/non-LPDDR3/non-LPDDR4 designs - Set this to tCKE value When the controller is operating in 1:2 frequency ratio mode, program this to (value described above)/2 and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | Minimum number of cycles of CKE HIGH/LOW during power-down and self refresh.  - LPDDR2/LPDDR3 mode: Set this to the larger of tCKE or tCKESR  - LPDDR4 mode: Set this to the larger of tCKE or tSR.  - Non-LPDDR2/non-LPDDR3/non-LPDDR4 designs: Set this to tCKE value.  When the controller is operating in 1:2 frequency ratio mode, program this to (value described above)/2 and round it up to the next integer value.  Unit: Clocks. Programming Mode: Quasi-dynamic Group 2 and Group 4

|===


=== DRAMTMG8 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| T_XS_DLL_X32

 2+| tXSDLL: Exit self-refresh to commands requiring a locked DLL. When the controller is operating in 1:2 frequency ratio mode, program this to the previous value divided by 2 and round up to next integer value. Note: Used only for DDR2, DDR3 and DDR4 SDRAMs. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see "Note 1" in the "Notes on Timing Registers" section. Programming Mode: Quasi-dynamic Group 2, Group 4 | tXSDLL: Exit Self Refresh to commands requiring a locked DLL. When the controller is operating in 1:2 frequency ratio mode, program this to the above value divided by 2 and round up to next integer value. Unit: Multiples of 32 clocks. Note: Used only for DDR2, DDR3 and DDR4 SDRAMs. Programming Mode: Quasi-dynamic Group 2 and Group 4

| T_XS_X32

 2+| tXS: Exit self-refresh to commands not requiring a locked DLL. When the controller is operating in 1:2 frequency ratio mode, program this to the previous value divided by 2 and round up to next integer value. Note: Used only for DDR2, DDR3 and DDR4 SDRAMs. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see "Note 1" in the "Notes on Timing Registers" section. Programming Mode: Quasi-dynamic Group 2, Group 4 | tXS: Exit Self Refresh to commands not requiring a locked DLL. When the controller is operating in 1:2 frequency ratio mode, program this to the above value divided by 2 and round up to next integer value. Unit: Multiples of 32 clocks. Note: Used only for DDR2, DDR3 and DDR4 SDRAMs. Programming Mode: Quasi-dynamic Group 2 and Group 4

| T_XS_ABORT_X32

 |  | tXS_ABORT: Exit self-refresh to commands not requiring a locked DLL in self-refresh Abort. When the controller is operating in 1:2 frequency ratio mode, program this to the previous value divided by 2 and round up to next integer value. Note: Ensure this is less than or equal to t_xs_x32. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see "Note 1" in the "Notes on Timing Registers" section. Programming Mode: Quasi-dynamic Group 2, Group 4 | tXS_ABORT: Exit Self Refresh to commands not requiring a locked DLL in Self Refresh Abort. When the controller is operating in 1:2 frequency ratio mode, program this to the above value divided by 2 and round up to next integer value. Unit: Multiples of 32 clocks. Note: Ensure this is less than or equal to t_xs_x32. Programming Mode: Quasi-dynamic Group 2 and Group 4

| T_XS_FAST_X32

 |  | tXS_FAST: Exit self-refresh to ZQCL, ZQCS and MRS (only CL, WR, RTP and Geardown mode). When the controller is operating in 1:2 frequency ratio mode, program this to the previous value divided by 2 and round up to next integer value. Note: This is applicable to only ZQCL/ZQCS commands.  Note: Ensure this is less than or equal to t_xs_x32. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see "Note 1" in the "Notes on Timing Registers" section. Programming Mode: Quasi-dynamic Group 2, Group 4 | tXS_FAST: Exit Self Refresh to ZQCL, ZQCS and MRS (only CL, WR, RTP and Geardown mode). When the controller is operating in 1:2 frequency ratio mode, program this to the above value divided by 2 and round up to next integer value. Unit: Multiples of 32 clocks. Note: This is applicable to only ZQCL/ZQCS commands.  Note: Ensure this is less than or equal to t_xs_x32. Programming Mode: Quasi-dynamic Group 2 and Group 4

|===


=== DRAMTMG9 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| WR2RD_S

 |  | Minimum time from write command to read command for different bank group.  This must include time for bus turn-around and all PHY and system requirements.  After the PHY has completed training, the value programmed may need to be increased.  Please see the relevant PHY databook for details of what should be included here.  The following calculations are minimum values, and do not include the PHY/system requirements mentioned above:  CWL + BL/2 + tWTR_S  Where:  - CWL: CAS write latency  - BL: Burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - tWTR_S: Internal write to read command delay for different bank group. This comes directly from the SDRAM specification WTR_S must be increased by one if DDR4 2tCK write preamble is used. When the controller is operating in 1:2 mode, divide the value calculated using the previous equation by 2, and round it up to next integer.  If your configuration has RANKCTL1.wr2rd_dr, write to read bus turn-around between different physical ranks are controlled by RANKCTL1.wr2rd_dr.   Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 |  CWL + PL + BL/2 + tWTR_S Minimum time from write command to read command for different bank group. Includes time for bus turnaround, recovery times, and all per-bank, per-rank, and global constraints. Present only in designs configured to support DDR4. Unit: Clocks. Where:  - CWL = CAS write latency  - PL = Parity latency  - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - tWTR_S = internal write to read command delay for different bank group. This comes directly from the SDRAM specification. When the controller is operating in 1:2 mode, divide the value calculated using the above equation by 2, and round it up to next integer. Programming Mode: Quasi-dynamic Group 1 and Group 2 and Group 4

| T_RRD_S

 |  | tRRD_S: This is the minimum time between activates from bank "a" to bank "b" for different bank group. When the controller is operating in 1:2 frequency ratio mode, program this to (tRRD_S/2) and round it up to the next integer value. Present only in designs configured to support DDR4. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | tRRD_S: Minimum time between activates from bank "a" to bank "b" for different bank group. When the controller is operating in 1:2 frequency ratio mode, program this to (tRRD_S/2) and round it up to the next integer value. Present only in designs configured to support DDR4. Unit: Clocks. Programming Mode: Quasi-dynamic Group 2 and Group 4

| T_CCD_S

 |  | tCCD_S: This is the minimum time between two reads or two writes for different bank group. For bank switching (from bank "a" to bank "b"), the minimum time is this value + 1. When the controller is operating in 1:2 frequency ratio mode, program this to (tCCD_S/2) and round it up to the next integer value. Present only in designs configured to support DDR4. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4 | tCCD_S: This is the minimum time between two reads or two writes for different bank group. For bank switching (from bank "a" to bank "b"), the minimum time is this value + 1. When the controller is operating in 1:2 frequency ratio mode, program this to (tCCD_S/2) and round it up to the next integer value. Present only in designs configured to support DDR4. Unit: clocks. Programming Mode: Quasi-dynamic Group 2 and Group 4

| DDR4_WR_PREAMBLE

 |  | DDR4 Write preamble mode.    Present only with MEMC_FREQ_RATIO=2. Programming Mode: Quasi-dynamic Group 2, Group 4 | DDR4 Write preamble mode   - 0: 1tCK preamble   - 1: 2tCK preamble Present only with MEMC_FREQ_RATIO=2 Programming Mode: Quasi-dynamic Group 2 and Group 4

|===


=== DSGCR fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| CKEOE

 | SDRAM CKE Output Enable: Enables, when set, the output driver on the I/O for SDRAM CKE pins. 2+| 

| RSTOE

 | SDRAM Reset Output Enable: Enables, when set, the output driver on the I/O for SDRAM RST# pin. 2+| SDRAM Reset Output Enable.

| ODTOE

 | SDRAM ODT Output Enable: Enables, when set, the output driver on the I/O for SDRAM ODT pins. 2+| 

| CKOE

 | SDRAM CK Output Enable: Enables, when set, the output driver on the I/O for SDRAM CK/CK# pins. 2+| 

| ODTPDD

 | ODT Power Down Driver: Powers down, when set, the output driver on the I/O for ODT[3:0] pins. ODTPDD[0] controls the power down for ODT[0], ODTPDD[1] controls the power down for ODT[1], and so on. 2+| 

| CKEPDD

 | CKE Power Down Driver: Powers down, when set, the output driver on the I/O for CKE[3:0] pins. CKEPDD[0] controls the power down for CKE[0], CKEPDD[1] controls the power down for CKE[1], and so on. 2+| 

| SDRMODE

 | Single Data Rate Mode: Indicates, if set, that the external controller is configured to run in single data rate (SDR) mode. Otherwise if not set the controller is running in half data rate (HDR) mode. This bit not supported in the current version of the PUB. 2+| Single Data Rate Mode.

| RRMODE

 | Rise-to-Rise Mode: Indicates, if set, that the PHY mission mode is configured to run in rise-to-rise mode. Otherwise if not set the PHY mission mode is running in rise-to-fall mode. 2+| 

| ATOAE

 3+| ATO Analog Test Enable.

| DTOOE

 | DTO Output Enable: Enables, when set, the output driver on the I/O for DTO pins. 2+| DTO Output Enable.

| DTOIOM

 | DTO I/O Mode: Selects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for DTO pins. 2+| DTO I/O Mode.

| DTOPDR

 | DTO Power Down Receiver: Powers down, when set, the input receiver on the I/O for DTO pins. 2+| DTO Power Down Receiver.

| DTOPDD

 | DTO Power Down Driver: Powers down, when set, the output driver on the I/O for DTO pins. 2+| 

| DTOODT

 | DTO On-Die Termination: Enables, when set, the on-die termination on the I/O for DTO pins. 2+| DTO On-Die Termination.

| PUAD

 | PHY Update Acknowledge Delay: Specifies the number of clock cycles that the indication for the completion of PHY update from the PHY to the controller should be delayed. This essentially delays, by this many clock cycles, the deassertion of dfi_ctrlup_ack and dfi_phyupd_req signals relative to the time when the delay lines or I/Os are updated. 2+| PHY Update Acknowledge Delay.

| BRRMODE

 | Bypass Rise-to-Rise Mode: Indicates, if set, that the PHY bypass mode is configured to run in rise-to-rise mode. Otherwise if not set the PHY bypass mode is running in rise-to-fall mode. 2+| 

| DQSGX

 | DQS Gate Extension: Specifies, if set, that the DQS gating must be extended by two DRAM clock cycles and then re-centered, i.e. one clock cycle extension on either side. 2+| DQS Gate Extension.

| CUAEN

 | Controller Update Acknowledge Enable: Specifies, if set, that the PHY should issue controller update acknowledge when the DFI controller update request is asserted. By default the PHY does not acknowledge controller initiated update requests but simply does an update whenever there is a controller update request. This speeds up the update. 2+| Controller Update Acknowledge Enable.

| LPPLLPD

 | Low Power PLL Power Down: Specifies, if set, that the PHY should respond to the DFI low power opportunity request and power down the PLL of the byte if the wakeup time request satisfies the PLL lock time. 2+| Low Power PLL Power Down.

| LPIOPD

 | Low Power I/O Power Down: Specifies, if set, that the PHY should respond to the DFI low power opportunity request and power down the I/Os of the byte. 2+| Low Power I/O Power Down.

| ZUEN

 | Impedance Update Enable: Specifies, if set, that in addition to DDL VT update, the PHY could also perform impedance calibration (update). Refer to the "Impedance Control Register 0-1 (ZQnCR0-1)"  bit fields DFICU0, DFICU1 and DFICCU bits to control if an impedance calibration is performed (update) with a DFI controller update request. Refer to the "Impedance Control Register 0-1 (ZQnCR0-1)" bit fields DFIPU0 and DFIPU1 bits to control if an impedance calibration is performed (update) with a DFI PHY update request. 2+| 

| BDISEN

 | Byte Disable Enable: Specifies, if set, that the PHY should respond to DFI byte disable request. Otherwise the byte disable from the DFI is ignored in which case bytes can only be disabled using the DXnGCR register. 2+| Byte Disable Enable.

| PUREN

 | PHY Update Request Enable: Specifies if set, that the PHY should issue PHYinitiated update request when there is DDL VT drift. 2+| PHY Update Request Enable.

| CTLZUEN

 |  2+| Controller Impedance Update Enable.

| RESERVED_13

 |  2+| Reserved for future use.

| WRRMODE

 |  2+| Write Path Rise-to-Rise Mode.

| RRRMODE

 |  2+| Read Path Rise-to-Rise Mode.

| PHYZUEN

 |  2+| PHY Impedance Update Enable.

| LPACIOPD

 |  | Low Power AC I/O Power Down. | 

| RESERVED_31_25

 |  | Reserved for future use. | 

| RESERVED_31_24

 2+|  | Reserved for future use.

|===


=== DTCR fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| RFSHDT

 | Refresh During Training: A non-zero value specifies that a burst of refreshes equal to the number specified in this field should be sent to the SDRAM after training each rank except the last rank. 2+| 

| RANKEN

 | Rank Enable: Specifies the ranks that are enabled for data-training. Bit 0 controls rank 0, bit 1 controls rank 1, bit 2 controls rank 2, and bit 3 controls rank 3. Setting the bit to '1' enables the rank, and setting it to '0' disables the rank. 2+| 

| DTEXD

 | Data Training Extended Write DQS: Enables, if set, an extended write DQS whereby two additional pulses of DQS are added as post-amble to a burst of writes. Generally this should only be enabled when running read bit deskew with the intention of performing read eye deskew prior to running write leveling adjustment. 2+| 

| DTDSTP

 | Data Training Debug Step: A write of 1 to this bit steps the data training algorithm through a single step. This bit is used to initiate one step of the data training algorithm in question. This bit is self-clearing. To trigger the next step, this bit must be written to again. Note: The training steps must be repeated in order to get new data in the "Data Training Eye Data Register 0-1 (DTEDR0-1)" For example, to see the training results for a different lane, select that lane and repeat the training steps to populate DTEDR0 and DTEDR1 with the correct data. 2+| 

| DTDEN

 | Data Training Debug Enable: Enables, if set, the data training single step debug mode. 2+| 

| DTDBS

 | Data Training Debug Byte Select: Selects the byte during data training single step debug mode. Note: DTDEN is not used to enable this feature. 2+| 

| DTWDQMO

 | Data Training WDQ Margin Override: If set, the Training WDQ Margin value specified in DTCR[11:8] (DTWDQM) is used during data training. Otherwise the value is computed as &#xBC; of the ddr_clk period measurement found during calibration of the WDQ LCDL. 2+| 

| DTBDC

 | Data Training Bit Deskew Centering: Enables, if set, eye centering capability during write and read bit deskew training. 2+| 

| DTWBDDM

 | Data Training Write Bit Deskew Data Mask, if set, it enables write bit deskew of the data mask. 2+| 

| DTWDQM

 | Training WDQ Margin: Defines how close to 0 or how close to 2*(wdq calibration_value) the WDQ LCDL can be moved during training. Basically defines how much timing margin. 2+| 

| DTCMPD

 | Read Data Training Compare Data: Specifies, if set, that DQS gate training should also check if the returning read data is correct. Otherwise data-training only checks if the correct number of DQS edges were returned. 2+| 

| DTMPR

 | Read Data Training Using MPR (DDR3 Only): Specifies, if set, that DQS gate training should use the SDRAM Multi-Purpose Register (MPR) register. Otherwise data-training is performed by first writing to some locations in the SDRAM and then reading them back. 2+| 

| DTRANK

 | Data Training Rank: Select the SDRAM rank to be used during Read DQS gate training, Read/Write Data Bit Deskew, Read/Write Eye Training. 2+| 

| DTRPTN

 | Data Training Repeat Number: Repeat number used to confirm stability of DDR write or read. Note: The minimum value should be 0x4 2+| 

|===


=== DTCR0 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DTRPTN

 |  2+| Data Training Repeat Number.

| RESERVED_5_4

 |  2+| Reserved for future use.

| DTMPR

 |  2+| Data Training Using MPR.

| DTCMPD

 |  2+| Data Training Compare Data.

| RESERVED_10_8

 |  2+| Reserved for future use.

| DTDBS4

 |  2+| Data Training Debug Byte Select Most Significant Bit.

| DTWBDDM

 |  2+| Data Training Write Bit Deskew Data Mask.

| DTBDC

 |  2+| Data Training Bit Deskew Centering.

| DTRDBITR

 |  2+| Data Training read DBI deskewing configuration.

| DTDBS

 |  2+| Data Training Debug Byte Select.

| DTDEN

 |  2+| Data Training Debug Enable.

| DTDSTP

 |  2+| Data Training Debug Step.

| DTEXD

 |  2+| Data Training Extended Write DQS.

| RESERVED_23

 |  | Reserved for future use. | 

| DTDRS

 |  2+| Data Training Debug Rank Select.

| RESERVED_27_26

 |  2+| Reserved for future use.

| RFSHDT

 |  2+| Refresh During Training and BIST.

| DTEXG

 2+|  | Data Training with Early/Extended Gate.

|===


=== DTCR1 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| BSTEN

 |  2+| Basic Gate Training Enable.

| RDLVLEN

 |  2+| Read Leveling Enable.

| RDPRMBL_TRN

 |  2+| Read Preamble Training Enable.

| RESERVED_3

 |  2+| Reserved for future use.

| RDLVLGS

 |  2+| Read Leveling Gate Shift.

| RESERVED_7

 |  2+| Reserved for future use.

| RDLVLGDIFF

 |  2+| Read Leveling Gate Sampling Difference.

| WLVLDPRD

 |  | Write Leveling Validation Period. | 

| DTRANK

 |  2+| Data Training Rank.

| RESERVED_15_14

 |  2+| Reserved for future use.

| RANKEN

 |  2+| Rank Enable.

| RANKEN_RSVD

 |  2+| Rank Enable Reserved

| RESERVED_11

 2+|  | Reserved for future use.

|===


=== DTPR0 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TRC

 | Activate to activate command delay (same bank). Valid values are 2 to 63. 2+| 

| TRRD

 | Activate to activate command delay (different banks). Valid values are 1 to 15. 2+| Activate to activate command delay (different banks).

| TRAS

 | Activate to precharge command delay. Valid values are 2 to 63. 2+| Activate to precharge command delay.

| TRCD

 | Activate to read or write delay. Minimum time from when an activate command is issued to when a read or write to the activated row can be issued. Valid values are 2 to 15. 2+| 

| TRP

 | Precharge command period: The minimum time between a precharge command and any other command. Note that the Controller automatically derives tRPA for 8- bank DDR2 devices by adding 1 to tRP. Valid values are 2 to 15. 2+| Precharge command period.

| TWTR

 | Internal write to read command delay. Valid values are 1 to 15. 2+| 

| TRTP

 | Internal read to precharge command delay. Valid values are 2 to 15. 2+| Internal read to precharge command delay.

| RESERVED_7_4

 |  2+| Reserved for future use.

| RESERVED_15

 |  2+| Reserved for future use.

| RESERVED_23

 |  2+| Reserved for future use.

| RESERVED_31_30

 |  2+| Reserved for future use.

|===


=== DTPR1 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TAON_OFF_D

 | ODT turn-on/turn-off delays (DDR2 only). The delays are in clock cycles. Valid values are: 00 = 2/2.5 01 = 3/3.5 10 = 4/4.5 11 = 5/5.5 Most DDR2 devices utilize a fixed value of 2/2.5. For non-standard SDRAMs, the user must ensure that the operational Write Latency is always greater than or equal to the ODT turn-on delay. For example, a DDR2 SDRAM with CAS latency set to 3 and CAS additive latency set to 0 has a Write Latency of 2. Thus 2/2.5 can be used, but not 3/3.5 or higher. 2+| 

| TWLO

 | Write leveling output delay: Number of clock cycles from when write leveling DQS is driven high by the control block to when the results from the SDRAM on DQ is sampled by the control block. This must include the SDRAM tWLO timing parameter plus the round trip delay from control block to SDRAM back to control block. 2+| 

| TWLMRD

 | Minimum delay from when write leveling mode is programmed to the first DQS/DQS# rising edge. 2+| Minimum delay from when write leveling mode is programmed to the first DQS/DQS# rising edge..

| TRFC

 | Refresh-to-Refresh: Indicates the minimum time, in clock cycles, between two refresh commands or between a refresh and an active command. This is derived from the minimum refresh interval from the datasheet, tRFC(min), divided by the clock cycle time. The default number of clock cycles is for the largest JEDEC tRFC(min parameter value supported. 2+| 

| TFAW

 | 4-bank activate period. No more than 4-bank activate commands may be issued in a given tFAW period. Only applies to 8-bank devices. Valid values are 2 to 63. 2+| 4-bank activate period.

| TMOD

 | Load mode update delay (DDR3 only). The minimum time between a load mode register command and a non-load mode register command. Valid values are: 000 = 12 001 = 13 010 = 14 011 = 15 100 = 16 101 = 17 110 - 111 = Reserved. 2+| Load mode update delay.

| TMRD

 | Load mode cycle time: The minimum time between a load mode register command and any other command. For DDR3 this is the minimum time between two load mode register commands. Valid values for DDR2 are 2 to 3. For DDR3, the value used for tMRD is 4 plus the value programmed in these bits, i.e. tMRD value for DDR3 ranges from 4 to 7. 2+| Load mode cycle time.

| RESERVED_7_5

 |  2+| Reserved for future use.

| RESERVED_15_11

 |  2+| Reserved for future use.

| RESERVED_31_30

 |  2+| Reserved for future use.

|===


=== DTPR2 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TCCD

 | Read to read and write to write command delay. Valid values are: 0 = BL/2 for DDR2 and 4 for DDR3 1 = BL/2 + 1 for DDR2 and 5 for DDR3 2+| 

| TRTW

 | Read to Write command delay. Valid values are: 0 = standard bus turn around delay 1 = add 1 clock to standard bus turn around delay This parameter allows the user to increase the delay between issuing Write commands to the SDRAM when preceded by Read commands. This provides an option to increase bus turn-around margin for high frequency systems. 2+| Read to Write command delay.

| TRTODT

 | Read to ODT delay (DDR3 only). Specifies whether ODT can be enabled immediately after the read post-amble or one clock delay has to be added. Valid values are: 0 = ODT may be turned on immediately after read post-amble 1 = ODT may not be turned on until one clock after the read post-amble If tRTODT is set to 1, then the read-to-write latency is increased by 1 if ODT is enabled. 2+| Read to ODT delay.

| TDLLK

 | DLL locking time. Valid values are 2 to 1023. 2+| 

| TCKE

 | CKE minimum pulse width. Also specifies the minimum time that the SDRAM must remain in power down or self refresh mode. For DDR3 this parameter must be set to the value of tCKESR which is usually bigger than the value of tCKE. Valid values are 2 to 15. 2+| CKE minimum pulse width.

| TXP

 | Power down exit delay. The minimum time between a power down exit command and any other command. This parameter must be set to the maximum of the various minimum power down exit delay parameters specified in the SDRAM datasheet, i.e. max(tXP, tXARD, tXARDS) for DDR2 and max(tXP, tXPDLL) for DDR3. Valid values are 2 to 31. 2+| 

| TXS

 | Self refresh exit delay. The minimum time between a self refresh exit command and any other command. This parameter must be set to the maximum of the various minimum self refresh exit delay parameters specified in the SDRAM datasheet, i.e. max(tXSNR, tXSRD) for DDR2 and max(tXS, tXSDLL) for DDR3. Valid values are 2 to 1023. 2+| Self refresh exit delay.

| RESERVED_15_10

 |  2+| Reserved for future use.

| RESERVED_23_20

 |  2+| Reserved for future use.

| RESERVED_27_25

 |  2+| Reserved for future use.

| RESERVED_31_29

 |  2+| Reserved for future use.

|===


=== DTPR3 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TDQSCK

 |  2+| DQS output access time from CK/CK#.

| RESERVED_7_3

 |  2+| Reserved for future use.

| TDQSCKMAX

 |  2+| Maximum DQS output access time from CK/CK#.

| RESERVED_15_11

 |  2+| Reserved for future use.

| TDLLK

 |  2+| DLL locking time.

| TCCD

 |  2+| Read to read and write to write command delay.

| TOFDX

 |  2+| ODT turn-off delay extension.

|===


=== DTPR4 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TXP

 |  2+| Power down exit delay.

| RESERVED_7_5

 |  2+| Reserved for future use.

| TWLO

 |  2+| Write leveling output delay.

| RESERVED_15_12

 |  2+| Reserved for future use.

| TRFC

 |  2+| Refresh-to-Refresh.

| RESERVED_27_26

 |  2+| Reserved for future use.

| TAOND_TAOFD

 |  2+| ODT turn-on/turn-off delays.

| RESERVED_31_30

 |  2+| Reserved for future use.

|===


=== DTPR5 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TWTR

 |  2+| Internal write to read command delay.

| RESERVED_7_5

 |  2+| Reserved for future use.

| TRCD

 |  2+| Activate to read or write delay.

| RESERVED_15

 |  2+| Reserved for future use.

| TRC

 |  2+| Activate to activate command delay (same bank).

| RESERVED_31_24

 |  2+| Reserved for future use.

|===


=== DXCCR fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DDPDRCDO

 | Dynamic Data Power Down Receiver Count Down Offset: Offset applied in calculating window of time where receiver is powered up 2+| 

| DDPDDCDO

 | Dynamic Data Power Down Driver Count Down Offset: Offset applied in calculating window of time where driver is powered up 2+| 

| DYNDXPDR

 | Data Power Down Receiver: Dynamically powers down, when set, the input receiver on I/O for the DQ pins of the active DATX8 macros. Applies only when DXPDR and DXnGCR.DXPDR are not set to 1. Receiver is powered-up on a DFI READ command and powered-down (trddata_en + fixed_read_latency + n) HDR cycles after the last DFI READ command. Note that n is defined by the register bit field DXCCR[31:28] (DDPDRCDO). 2+| 

| DYNDXPDD

 | Dynamic Data Power Down Driver: Dynamically powers down, when set, the output driver on I/O for the DQ pins of the active DATX8 macros. Applies only when DXPDD and DXnGCR.DXPDD are not set to 1. Driver is powered-up on a DFI WRITE command and powered-down (twrlat + WL/2 + n) HDR cycles after the last DFI WRITE command. Note that n is defined by the register bit field DXCCR[27:24] (DDPDDCDO). 2+| 

| UDQIOM

 | Unused DQ I/O Mode: Selects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for unused DQ pins. 2+| Unused DQ I/O Mode.

| UDQPDR

 | Unused DQ Power Down Receiver: Powers down, when set, the input receiver on the I/O for unused DQ pins. 2+| 

| UDQPDD

 | Unused DQ Power Down Driver: Powers down, when set, the output driver on the I/O for unused DQ pins. 2+| 

| UDQODT

 | Unused DQ On-Die Termination: Enables, when set, the on-die termination on the I/O for unused DQ pins. 2+| 

| MSBUDQ

 | Most Significant Byte Unused DQs: Specifies the number of DQ bits that are not used in the most significant byte. The used (valid) bits for this byte are [8-MSBDQ- 1:0]. To disable the whole byte, use the DXnGCR.DXEN register. 2+| Most Significant Byte Unused DQs.

| DQSNRES

 | DQS Resistor: Selects the on-die pull-down/pull-up resistor for DQS pins. DQSRES[3] selects pull-down (when set to 0) or pull-up (when set to 1). DQSRES[2:0] selects the resistor value. Refer PHY databook for pull-down/pull-up resistor values (RA_SEL/RB_SEL) for DQS/DQS_b. 2+| DQS# Resistor.

| DQSRES

 | DQS Resistor: Selects the on-die pull-down/pull-up resistor for DQS pins. DQSRES[3] selects pull-down (when set to 0) or pull-up (when set to 1). DQSRES[2:0] selects the resistor value. Refer PHY databook for pull-down/pull-up resistor values (RA_SEL/RB_SEL) for DQS/DQS_b. 2+| DQS Resistor.

| DXPDR

 | Data Power Down Receiver: Powers down, when set, the input receiver on I/O for DQ, DM, and DQS/DQS# pins of all DATX8 macros. This bit is ORed with the PDR configuration bit of the individual DATX8. 2+| 

| DXPDD

 | Data Power Down Driver: Powers down, when set, the output driver on I/O for DQ, DM, and DQS/DQS# pins of all DATX8 macros. This bit is ORed with the PDD configuration bit of the individual DATX8. 2+| 

| MDLEN

 | Master Delay Line Enable: Enables, if set, all DATX8 master delay line calibration to perform subsequent period measurements following the initial period measurements that are performed after reset or on when calibration is manually triggered. These additional measurements are accumulated and filtered as long as this bit remains high. This bit is ANDed with the MDLEN bit in the individual DATX8. 2+| Master Delay Line Enable.

| DXIOM

 | Data I/O Mode: Selects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for DQ, DM, and DQS/DQS# pins of all DATX8 macros. This bit is ORed with the IOM configuration bit of the individual DATX8. 2+| Data I/O Mode.

| DXODT

 | Data On-Die Termination: Enables, when set, the on-die termination on the I/O for DQ, DM, and DQS/DQS# pins of all DATX8 macros. This bit is ORed with the ODT configuration bit of the individual DATX8 ("DATX8 General Configuration Register (DXnGCR)" 2+| Data On-Die Termination.

| DQSGLB

 |  2+| Read DQS Gate I/O Loopback.

| DXSR

 |  2+| Data Slew Rate.

| RESERVED_19_18

 |  | Reserved for future use. | 

| QSCNTENCTL

 |  | QS Counter Enable Control. | 

| QSCNTEN

 |  2+| QS Counter Enable.

| DXDCCBYP

 |  2+| DATX8 Duty Cycle Correction Bypass.

| RESERVED_28_24

 |  2+| Reserved for future use.

| RKLOOP

 |  2+| Rank looping (per-rank eye centering) enable.

| X4DQSMD

 |  2+| X4 DQS Mode.

| X4MODE

 |  2+| X4 SDRAM Mode.

| RESERVED_20_18

 2+|  | Reserved for future use.

|===


=== ECCCFG0 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ECC_REGION_MAP_GRANU

 | Indicates granularity of selectable protected region. Define one region size for ECCCFG0.ecc_region_map.  - 0 - 1/8 of memory spaces   - 1 - 1/16 of memory spaces   - 2 - 1/32 of memory spaces   - 3 - 1/64 of memory spaces   Programming Mode: Static | Indicates granularity of selectable protected region. Define one region size for ECCCFG0.ecc_region_map. Programming Mode: Static | 

| ECC_REGION_MAP_OTHER

 | When ECCCFG0.ecc_region_map_granu&gt;0, there is a region which is not controlled by ecc_region_map. This register defines the region to be protected or non-protected for Inline ECC.  - 0 - Non-Protected  - 1 - Protected This register is valid only when ECCCFG0.ecc_region_map_granu&gt;0 &amp;&amp; ECCCFG0.ecc_mode=4.  Programming Mode: Static | When ECCCFG0.ecc_region_map_granu&gt;0, there is a region which is not controlled by ecc_region_map. This register defines the region to be protected or non-protected for Inline ECC.    This register is valid only when ECCCFG0.ecc_region_map_granu&gt;0 &amp;&amp; ECCCFG0.ecc_mode=4.  Programming Mode: Static | 

| ECC_AP_ERR_THRESHOLD

 2+| Sets threshold for address parity error. ECCAPSTAT.ecc_ap_err is asserted if number of ECC errors (correctable/uncorrectable) within one burst exceeds this threshold. This register value must be less than "Total number of ECC checks within one burst" when this feature is used, "Total number of ECC check within one burst" is calculated by (DRAM Data width) x (DRAM BL) / 64.   Programming Mode: Static | 

| BLK_CHANNEL_IDLE_TIME_X32

 2+| Indicates the number of cycles on HIF interface with no access to protected regions which causes flush of all the block channels. In order to flush block channel, uMCTL2 injects write ECC command (when there is no incoming HIF command) if there is any write in the block and then stop tracking the block address.  - 0 - Indicates no timeout (feature is disabled, not supported with this version)  - 1 - Indicates 32 cycles  - 2 - Indicates 2*32 cycles, and so on  Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see "Note 1" in the "Notes on Timing Registers" section. Programming Mode: Quasi-dynamic Group 3 | 

| ECC_REGION_MAP

 2+| Selectable Protected Region setting. Memory space is divided to 8/16/32/64 regions which is determined by ECCCFG0.ecc_region_map_granu. Note: Highest 1/8 memory space is always ECC region. Lowest 7 regions are Selectable Protected Regions. The Selectable Protected Regions can be protected/non-protected selectively by ECCCFG0.ecc_region_map[6:0]. Other upper regions are non-protected region if any. Each bit of ECCCFG0.ecc_region_map[6:0] correspond to each of lowest 7 regions respectively.  In order to protect a region with ECC, set the corresponding bit to 1, otherwise set to 0. All "0"s is invalid - there must be at least one protected region if inline ECC is enabled through ECCCFG0.ecc_mode register. All regions are protected with the following setting.  - ecc_region_map=7'b1111111  - ecc_region_map_granu=0 Only first 1/64 region is protected with the following setting.  - ecc_region_map=7'b0000001  - ecc_region_map_granu=3  Programming Mode: Quasi-dynamic Group 3 | 

| ECC_REGION_REMAP_EN

 | Enables remapping ECC region feature. Only supported when inline ECC is enabled.  - 0 - Disable  - 1 - Enable Programming Mode: Static | Enables remapping ECC region feature. Only supported when inline ECC is enabled. Programming Mode: Static | 

| ECC_AP_EN

 | Enables address protection feature. Only supported when inline ECC is enabled.  - 0 - Disable  - 1 - Enable Programming Mode: Static | Enables address protection feature. Only supported when inline ECC is enabled. Programming Mode: Static | 

| DIS_SCRUB

 2+| Disables ECC scrubs. Valid only when ECCCFG0.ecc_mode = 3'b100 or 3'b101 and MEMC_USE_RMW is defined. Note: Scrub is not supported in inline ECC mode and the register value is don't care.  Programming Mode: Static | Disable ECC scrubs. Valid only when ECCCFG0.ecc_mode = 3'b100 or 3'b101 and MEMC_USE_RMW is defined.       Note: Scrub is not supported in inline ECC mode and the register value is don't care.  Programming Mode: Static

| ECC_MODE

 | ECC mode indicator.  - 000 - ECC disabled  - 100 - ECC enabled - SEC/DED over 1 beat  - 101 - ECC enabled - Advanced ECC X4/X8 (Illegal value when MEMC_INLINE_ECC=1)  - all other settings are reserved for future use Programming Mode: Static | ECC mode indicator. Everything not described in "Values" section is reserved. Programming Mode: Static | ECC mode indicator  - 000 - ECC disabled  - 100 - ECC enabled - SEC/DED over 1 beat  - 101 - ECC enabled - Advanced ECC  - all other settings are reserved for future use Programming Mode: Static

|===


=== INIT0 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| SKIP_DRAM_INIT

 | If lower bit is enabled the SDRAM initialization routine is skipped. The upper bit decides what state the controller starts up in when reset is removed.    - 00 - SDRAM Initialization routine is run after power-up  - 01 - SDRAM Initialization routine is skipped after power-up. The controller starts up in normal Mode  - 11 - SDRAM Initialization routine is skipped after power-up. The controller starts up in self-refresh Mode  - 10 - Reserved Programming Mode: Quasi-dynamic Group 2 | If lower bit is enabled the SDRAM initialization routine is skipped. The upper bit decides what state the controller starts up in when reset is removed. Value "10" is reserved. Programming Mode: Quasi-dynamic Group 2 | If lower bit is enabled the SDRAM initialization routine is skipped. The upper bit decides what state the controller starts up in when reset is removed    - 00 - SDRAM Intialization routine is run after power-up  - 01 - SDRAM Intialization routine is skipped after power-up. Controller starts up in Normal Mode  - 11 - SDRAM Intialization routine is skipped after power-up. Controller starts up in Self-refresh Mode  - 10 - SDRAM Intialization routine is run after power-up. Programming Mode: Quasi-dynamic Group 2

| POST_CKE_X1024

 2+| Indicates the number of cycles to wait after driving CKE high to start the SDRAM initialization sequence. DDR2 typically requires a 400 ns delay, requiring this value to be programmed to 2 at all clock speeds. LPDDR2/LPDDR3 typically requires this to be programmed for a delay of 200 us. LPDDR4 typically requires this to be programmed for a delay of 2 us. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 1024 DFI clock cycles. For more information on how to program this register field, see "Note 1" in the "Notes on Timing Registers" section. Programming Mode: Static | Cycles to wait after driving CKE high to start the SDRAM initialization sequence. Unit: 1024 DFI clock cycles. DDR2 typically requires a 400 ns delay, requiring this value to be programmed to 2 at all clock speeds. LPDDR2/LPDDR3 typically requires this to be programmed for a delay of 200 us. LPDDR4 typically requires this to be programmed for a delay of 2 us. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Programming Mode: Static

| PRE_CKE_X1024

 2+| Indicates the number of cycles to wait after reset before driving CKE high to start the SDRAM initialization sequence. DDR2 specifications typically require this to be programmed for a delay of &gt;= 200 us. LPDDR2/LPDDR3: tINIT1 of 100 ns (min)  LPDDR4: tINIT3 of 2 ms (min)  When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. For DDR3/DDR4 RDIMMs, this must include the time needed to satisfy tSTAB. Unit: Multiples of 1024 DFI clock cycles. For more information on how to program this register field, see "Note 1" in the "Notes on Timing Registers" section. Programming Mode: Static | Cycles to wait after reset before driving CKE high to start the SDRAM initialization sequence. Unit: 1024 DFI clock cycles. DDR2 specifications typically require this to be programmed for a delay of &gt;= 200 us. LPDDR2/LPDDR3: tINIT1 of 100 ns (min)  LPDDR4: tINIT3 of 2 ms (min)   When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. For DDR3/DDR4 RDIMMs, this should include the time needed to satisfy tSTAB Programming Mode: Static

|===


=== INIT1 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DRAM_RSTN_X1024

 2+| Indicates the number of cycles to assert SDRAM reset signal during init sequence. This is only present for designs supporting DDR3, DDR4 or LPDDR4 devices. For use with a Synopsys DDR PHY, this must be set to a minimum of 1. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 1024 DFI clock cycles. For more information on how to program this register field, see "Note 1" in the "Notes on Timing Registers" section. Programming Mode: Static | Number of cycles to assert SDRAM reset signal during init sequence. This is only present for designs supporting DDR3, DDR4 or LPDDR4 devices. For use with a Synopsys DDR PHY, this should be set to a minimum of 1. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: 1024 DFI clock cycles. Programming Mode: Static

| PRE_OCD_X32

 2+| Indicates the wait period before driving the OCD complete command to SDRAM. There is no known specific requirement for this; it may be set to zero. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see "Note 1" in the "Notes on Timing Registers" section. Programming Mode: Static | Wait period before driving the OCD complete command to SDRAM. Unit: Counts of a global timer that pulses every 32 DFI clock cycles. There is no known specific requirement for this; it may be set to zero. Programming Mode: Static

|===


=== INIT3 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| MR

 | DDR2: Indicates the value to write to MR register. Bit 8 is for DLL and the setting here is ignored. The uMCTL2 sets this bit appropriately. DDR3/DDR4: Value loaded into MR0 register. mDDR: Value to write to MR register. LPDDR2/LPDDR3/LPDDR4 - Value to write to MR1 register Programming Mode: Quasi-dynamic Group 1, Group 4 | DDR2:Indicates the value to write to MR register. Bit 8 is for DLL and the setting here is ignored. The uMCTL2 sets this bit appropriately. DDR3/DDR4: Value loaded into MR0 register. mDDR: Value to write to MR register. LPDDR2/LPDDR3/LPDDR4 - Value to write to MR1 register Programming Mode: Quasi-dynamic Group 1, Group 4 | DDR2: Value to write to MR register. Bit 8 is for DLL and the setting here is ignored. The uMCTL2 sets this bit appropriately. DDR3/DDR4: Value loaded into MR0 register. mDDR: Value to write to MR register. LPDDR2/LPDDR3/LPDDR4 - Value to write to MR1 register Programming Mode: Quasi-dynamic Group 1 and Group 4

| EMR

 2+| DDR2: Indicates the value to write to EMR register. Bits 9:7 are for OCD and the setting in this register is ignored. The uMCTL2 sets those bits appropriately. DDR3/DDR4: Value to write to MR1 register Set bit 7 to 0. mDDR: Value to write to EMR register. LPDDR2/LPDDR3/LPDDR4 - Value to write to MR2 register. Programming Mode: Quasi-dynamic Group 4 | DDR2: Value to write to EMR register. Bits 9:7 are for OCD and the setting in this register is ignored. The uMCTL2 sets those bits appropriately. DDR3/DDR4: Value to write to MR1 register  Set bit 7 to 0.  If PHY-evaluation mode training is enabled, this bit is set appropriately by the uMCTL2 during write leveling.  mDDR: Value to write to EMR register. LPDDR2/LPDDR3/LPDDR4 - Value to write to MR2 register Programming Mode: Quasi-dynamic Group 4

|===


=== INIT4 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| EMR2

 2+| DDR2: Indicates the value to write to EMR2 register. DDR3/DDR4: Value to write to MR2 register. LPDDR2/LPDDR3/LPDDR4: Value to write to MR3 register. mDDR: Unused. Programming Mode: Quasi-dynamic Group 4 | DDR2: Value to write to EMR2 register. DDR3/DDR4: Value to write to MR2 register LPDDR2/LPDDR3/LPDDR4: Value to write to MR3 register mDDR: Unused Programming Mode: Quasi-dynamic Group 4

| EMR3

 2+| DDR2: Indicates the value to write to EMR3 register. DDR3/DDR4: Value to write to MR3 register. mDDR/LPDDR2/LPDDR3: Unused. LPDDR4: Value to write to MR13 register. Programming Mode: Quasi-dynamic Group 2, Group 4 | DDR2: Value to write to EMR3 register. DDR3/DDR4: Value to write to MR3 register mDDR/LPDDR2/LPDDR3: Unused LPDDR4: Value to write to MR13 register Programming Mode: Quasi-dynamic Group 2 and Group 4

|===


=== INIT5 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DEV_ZQINIT_X32

 2+| ZQ initial calibration, tZQINIT. Present only in designs configured to support DDR3 or DDR4 or LPDDR2/LPDDR3. DDR3 typically requires 512 SDRAM clock cycles. DDR4 requires 1024 SDRAM clock cycles. LPDDR2/LPDDR3 requires 1 us. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see "Note 1" in the "Notes on Timing Registers" section. Programming Mode: Static | ZQ initial calibration, tZQINIT. Present only in designs configured to support DDR3 or DDR4 or LPDDR2/LPDDR3. DDR3 typically requires 512 SDRAM clock cycles. DDR4 requires 1024 SDRAM clock cycles. LPDDR2/LPDDR3 requires 1 us. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: 32 DFI clock cycles. Programming Mode: Static

| MAX_AUTO_INIT_X1024

 2+|  | Maximum duration of the auto initialization, tINIT5. Present only in designs configured to support LPDDR2/LPDDR3. LPDDR2/LPDDR3 typically requires 10 us. Unit: 1024 DFI clock cycles. Programming Mode: Static

|===


=== INIT6 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| MR5

 |  | DDR4 - Indicates the value to be loaded into SDRAM MR5 registers. LPDDR4- Value to be loaded into SDRAM MR12 registers. Programming Mode: Quasi-dynamic Group 1, Group 4 | DDR4- Value to be loaded into SDRAM MR5 registers. LPDDR4- Value to be loaded into SDRAM MR12 registers. Programming Mode: Quasi-dynamic Group 1 and Group 4

| MR4

 |  | DDR4 - Indicates the value to be loaded into SDRAM MR4 registers. LPDDR4- Value to be loaded into SDRAM MR11 registers. Programming Mode: Quasi-dynamic Group 2, Group 4 | DDR4- Value to be loaded into SDRAM MR4 registers. LPDDR4- Value to be loaded into SDRAM MR11 registers. Programming Mode: Quasi-dynamic Group 2 and Group 4

|===


=== INIT7 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| MR6

 |  | DDR4 - Indicates the value to be loaded into SDRAM MR6 registers. LPDDR4- Value to be loaded into SDRAM MR14 registers. Programming Mode: Quasi-dynamic Group 4 | DDR4- Value to be loaded into SDRAM MR6 registers. LPDDR4- Value to be loaded into SDRAM MR14 registers. Programming Mode: Quasi-dynamic Group 4

|===


=== MSTR fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ACTIVE_RANKS

 | Only present for multi-rank configurations. Each bit represents one rank. For two-rank configurations, only bits[25:24] are present.  - 1 - Populated  - 0 - Unpopulated LSB is the lowest rank number. For two ranks following combinations are legal:  - 01 - One rank  - 11 - Two ranks  - Others - Reserved For four ranks following combinations are legal:  - 0001 - One rank  - 0011 - Two ranks  - 1111 - Four ranks  Programming Mode: Static | Only present for multi-rank configurations. Each bit represents one rank. For two-rank configurations, only bits[25:24] are present.  - 1 - Populated  - 0 - Unpopulated LSB is the lowest rank number. For two ranks only the following values are legal:  - OneRank  - Tworanks  - Others  - Reserved For four ranks following combinations are legal:  - 0001 - One rank  - 0011 - Two ranks  - 1111 - Four ranks  Programming Mode: Static | Only present for multi-rank configurations. Each bit represents one rank. For two-rank configurations, only bits[25:24] are present.  - 1 - populated  - 0 - unpopulated LSB is the lowest rank number.  For 2 ranks following combinations are legal:  - 01 - One rank  - 11 - Two ranks  - Others - Reserved. For 4 ranks following combinations are legal:  - 0001 - One rank  - 0011 - Two ranks  - 0111 - Three ranks  - 1111 - Four ranks  Programming Mode: Static

| BURST_RDWR

 | Indicates SDRAM burst length used:  - 0001 - Burst length of 2 (only supported for mDDR)  - 0010 - Burst length of 4  - 0100 - Burst length of 8  - 1000 - Burst length of 16 (only supported for mDDR, LPDDR2, and LPDDR4) All other values are reserved. This bit controls the burst size used to access the SDRAM. This must match the burst length mode register setting in the SDRAM. (For BC4/8 on-the-fly mode of DDR3 and DDR4, set this field to 0x0100) Burst length of 2 is not supported with AXI ports when MEMC_BURST_LENGTH is 8. Burst length of 2 is only supported when the controller is operating in 1:1 frequency mode.  For DDR3, DDR4 and LPDDR3, this must be set to 0x0100 (BL8). For LPDDR4, this must be set to 0x1000 (BL16). Programming Mode: Static | Indicates SDRAM burst length used.    All other values are reserved.(See "Values" section) This bit controls the burst size used to access the SDRAM. This must match the burst length mode register setting in the SDRAM. (For BC4/8 on-the-fly mode of DDR3 and DDR4, set this field to 0x0100) Burst length of 2 is not supported with AXI ports when MEMC_BURST_LENGTH is 8. Burst length of 2 is only supported when the controller is operating in 1:1 frequency mode.  For DDR3, DDR4 and LPDDR3, this must be set to 0x0100 (BL8). For LPDDR4, this must be set to 0x1000 (BL16). Programming Mode: Static | SDRAM burst length used:  - 0001 - Burst length of 2 (only supported for mDDR)  - 0010 - Burst length of 4  - 0100 - Burst length of 8  - 1000 - Burst length of 16 (only supported for mDDR, LPDDR2, and LPDDR4)  All other values are reserved. This controls the burst size used to access the SDRAM. This must match the burst length mode register setting in the SDRAM. (For BC4/8 on-the-fly mode of DDR3 and DDR4, set this field to 0x0100) Burst length of 2 is not supported with AXI ports when MEMC_BURST_LENGTH is 8.   Burst length of 2 is only supported when the controller is operating in 1:1 frequency mode.    For DDR3, DDR4 and LPDDR3, this must be set to 0x0100 (BL8).    For LPDDR4, this must be set to 0x1000 (BL16). Programming Mode: Static

| DLL_OFF_MODE

 | Set to:  - 1 - When the uMCTL2 and DRAM has to be put in DLL-off mode for low frequency operation  - 0 - To put uMCTL2 and DRAM in DLL-on mode for normal frequency operation  If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), dll_off_mode is not supported, and this bit must be set to '0'.  Programming Mode: Quasi-dynamic Group 2 | Sets DLL-off mode. If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), dll_off_mode is not supported, and this bit must be set to '0'. Programming Mode: Quasi-dynamic Group 2 | Set to 1 when the uMCTL2 and DRAM has to be put in DLL-off mode for low frequency operation.  Set to 0 to put uMCTL2 and DRAM in DLL-on mode for normal frequency operation.  If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), dll_off_mode is not supported, and this bit must be set to '0'.  Programming Mode: Quasi-dynamic Group 2

| DATA_BUS_WIDTH

 | Selects proportion of DQ bus width that is used by the SDRAM.  - 00 - Full DQ bus width to SDRAM  - 01 - Half DQ bus width to SDRAM  - 10 - Quarter DQ bus width to SDRAM  - 11 - Reserved Note that half bus width mode is only supported when the SDRAM bus width is a multiple of 16, and quarter bus width mode is only supported when the SDRAM bus width is a multiple of 32 and the configuration parameter MEMC_QBUS_SUPPORT is set. Bus width refers to DQ bus width (excluding any ECC width). Programming Mode: Static | Selects proportion of DQ bus width that is used by the SDRAM.    Note that half bus width mode is only supported when the SDRAM bus width is a multiple of 16, and quarter bus width mode is only supported when the SDRAM bus width is a multiple of 32 and the configuration parameter MEMC_QBUS_SUPPORT is set. Bus width refers to DQ bus width (excluding any ECC width). Programming Mode: Static | Selects proportion of DQ bus width that is used by the SDRAM  - 00 - Full DQ bus width to SDRAM  - 01 - Half DQ bus width to SDRAM  - 10 - Quarter DQ bus width to SDRAM  - 11 - Reserved. Note that half bus width mode is only supported when the SDRAM bus width is a multiple of 16, and quarter bus width mode is only supported when the SDRAM bus width is a multiple of 32 and the configuration parameter MEMC_QBUS_SUPPORT is set. Bus width refers to DQ bus width (excluding any ECC width). Programming Mode: Static

| EN_2T_TIMING_MODE

 | If 1, then uMCTL2 uses 2T timing, otherwise uses 1T timing. In 2T timing, all command signals (except chip select) are held for 2 clocks on the SDRAM bus. Chip select is asserted on the second cycle of the command. Note:   - 2T timing is not supported in LPDDR2/LPDDR3/LPDDR4 mode  - 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set  - 2T timing is not supported in DDR4 geardown mode  - 2T timing is not supported in Shared-AC dual channel mode and the register value is don't care Programming Mode: Static | Sets uMCTL2 timing mode. In 2T timing, all command signals (except chip select) are held for 2 clocks on the SDRAM bus. Chip select is asserted on the second cycle of the command. Note:   - 2T timing is not supported in LPDDR2/LPDDR3/LPDDR4 mode  - 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set  - 2T timing is not supported in DDR4 geardown mode  - 2T timing is not supported in Shared-AC dual channel mode and the register value is don't care Programming Mode: Static | If 1, then uMCTL2 uses 2T timing. Otherwise, uses 1T timing. In 2T timing, all command signals (except chip select) are held for 2 clocks on the SDRAM bus. Chip select is asserted on the second cycle of the command Note: 2T timing is not supported in LPDDR2/LPDDR3/LPDDR4 mode Note: 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set Note: 2T timing is not supported in DDR4 geardown mode. Note: 2T timing is not supported in Shared-AC dual channel mode and the register value is don't care. Programming Mode: Static

| BURSTCHOP

 | When this bit is set, enables burst-chop (BC4 or 8 on-the-fly) in DDR3/DDR4. Burst Chop for reads is exercised only:  - In HIF configurations (UMCTL2_INCL_ARB not set)  - If in full bus width mode (MSTR.data_bus_width = 00)  - If MEMC_BURST_LENGTH=8 or 16 Burst Chop for writes is exercised only:  - If CRC is disabled (CRCPARCTL1.crc_enable = 0) BC4 (fixed) mode is not supported. Programming Mode: Static | Enables Burst Chop(BC4 or 8 on-the-fly) in DDR3/DDR4. Burst Chop for reads is exercised only:  - In HIF configurations (UMCTL2_INCL_ARB not set)  - If in full bus width mode (MSTR.data_bus_width = 00)  - If MEMC_BURST_LENGTH=8 or 16 Burst Chop for writes is exercised only:  - If CRC is disabled (CRCPARCTL1.crc_enable = 0) BC4 (fixed) mode is not supported. Programming Mode: Static | When set, enable burst-chop (BC4 or 8 on-the-fly) in DDR3/DDR4. Burst Chop for Reads is exercised only in HIF configurations (UMCTL2_INCL_ARB not set) and if in full bus width mode (MSTR.data_bus_width = 00) and if MEMC_BURST_LENGTH=8 or 16. Burst Chop for Writes is exercised only if Partial Writes enabled (UMCTL2_PARTIAL_WR=1) and if CRC is disabled (CRCPARCTL1.crc_enable = 0). If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), burst chop is not supported, and this bit must be set to '0'. BC4 (fixed) mode is not supported. Programming Mode: Static

| DDR3

 | Selects DDR3 SDRAM.  - 1 - DDR3 SDRAM device in use  - 0 - non-DDR3 SDRAM device in use Present only in designs configured to support DDR3. Programming Mode: Static | Selects DDR3 SDRAM.   Present only in designs configured to support DDR3. Programming Mode: Static | Select DDR3 SDRAM  - 1 - DDR3 SDRAM device in use  - 0 - non-DDR3 SDRAM device in use Only present in designs that support DDR3. Programming Mode: Static

| DDR4

 |  | Selects DDR4 SDRAM.   Present only in designs configured to support DDR4. Programming Mode: Static | Select DDR4 SDRAM  - 1 - DDR4 SDRAM device in use.  - 0 - non-DDR4 device in use Present only in designs configured to support DDR4. Programming Mode: Static

| GEARDOWN_MODE

 |  | Indicates the DRAM in geardown mode.   This register can be changed, only when the controller is in the self-refresh mode. This signal must be set the same value as MR3 bit A3.  Note:   - Geardown mode is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set  - Geardown mode is not supported if the configuration parameter UMCTL2_SHARED_AC is set (in Shared-AC mode) and the register value is don't care Programming Mode: Quasi-dynamic Group 2 | 1 indicates put the DRAM in geardown mode (2N) and 0 indicates put the DRAM in normal mode (1N). This register can be changed, only when the Controller is in self-refresh mode. This signal must be set the same value as MR3 bit A3. Note: Geardown mode is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set Note: Geardown mode is not supported if the configuration parameter UMCTL2_SHARED_AC is set (in Shared-AC mode) and the register value is don't care Programming Mode: Quasi-dynamic Group 2

| DEVICE_CONFIG

 |  | Indicates the configuration of the device used in the system. Programming Mode: Static | Indicates the configuration of the device used in the system.  - 00 - x4 device  - 01 - x8 device  - 10 - x16 device  - 11 - x32 device Programming Mode: Static

| LPDDR2

 2+|  | Select LPDDR2 SDRAM  - 1 - LPDDR2 SDRAM device in use.  - 0 - non-LPDDR2 device in use Present only in designs configured to support LPDDR2. Programming Mode: Static

| LPDDR3

 2+|  | Select LPDDR3 SDRAM  - 1 - LPDDR3 SDRAM device in use.  - 0 - non-LPDDR3 device in use Present only in designs configured to support LPDDR3. Programming Mode: Static

|===


=== ODTCFG fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| WR_ODT_HOLD

 2+| DFI PHY clock cycles to hold ODT for a write command. The minimum supported value is 2. Recommended values: DDR2:  - BL8 - 0x5 (DDR2-400/533/667), 0x6 (DDR2-800), 0x7 (DDR2-1066)  - BL4 - 0x3 (DDR2-400/533/667), 0x4 (DDR2-800), 0x5 (DDR2-1066) DDR3:  - BL8 - 0x6 DDR4:   - BL8 - 5 + WR_PREAMBLE + CRC_MODE    WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble)    CRC_MODE = 0 (not CRC mode), 1 (CRC mode) LPDDR3:  - BL8 - 7 + RU(tODTon(max)/tCK) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4 |  DFI PHY clock cycles to hold ODT for a write command. The minimum supported value is 2.  Recommended values:   DDR2:  - BL8:  0x5 (DDR2-400/533/667),  0x6 (DDR2-800),  0x7 (DDR2-1066)  - BL4:  0x3 (DDR2-400/533/667),  0x4 (DDR2-800),  0x5 (DDR2-1066)  DDR3:  - BL8: 0x6  DDR4:   - BL8: 5 + WR_PREAMBLE + CRC_MODE     WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)     CRC_MODE = 0 (not CRC mode),  1 (CRC mode)   LPDDR3:  - BL8: 7 + RU(tODTon(max)/tCK) Programming Mode: Quasi-dynamic Group 1 and Group 4

| WR_ODT_DELAY

 2+| Indicates the delay, in DFI PHY clock cycles, from issuing a write command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2. Recommended values: DDR2:  - CWL + AL - 3 (DDR2-400/533/667), CWL + AL - 4 (DDR2-800), CWL + AL - 5 (DDR2-1066)    If (CWL + AL - 3  &lt; 0), uMCTL2 does not support ODT for write operation.  DDR3:  - 0x0  DDR4:  - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)   LPDDR3:  - WL - 1 - RU(tODTon(max)/tCK)) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4 |  The delay, in DFI PHY clock cycles, from issuing a write command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2.  Recommended values:   DDR2:  - CWL + AL - 3 (DDR2-400/533/667),  CWL + AL - 4 (DDR2-800),  CWL + AL - 5 (DDR2-1066)     If (CWL + AL - 3  &lt; 0),  uMCTL2 does not support ODT for write operation.   DDR3:  - 0x0  DDR4:  - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)   LPDDR3:  - WL - 1 - RU(tODTon(max)/tCK)) Programming Mode: Quasi-dynamic Group 1 and Group 4

| RD_ODT_HOLD

 2+| DFI PHY clock cycles to hold ODT for a read command. The minimum supported value is 2. Recommended values: DDR2:  - BL8 - 0x6 (not DDR2-1066), 0x7 (DDR2-1066)  - BL4 - 0x4 (not DDR2-1066), 0x5 (DDR2-1066) DDR3:  - BL8 - 0x6 DDR4:  - BL8 - 5 + RD_PREAMBLE    RD_PREAMBLE = 1 (1tCK read preamble), 2 (2tCK read preamble) LPDDR3:  - BL8 - 5 + RU(tDQSCK(max)/tCK) - RD(tDQSCK(min)/tCK) + RU(tODTon(max)/tCK) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4 |  DFI PHY clock cycles to hold ODT for a read command. The minimum supported value is 2.  Recommended values:   DDR2:  - BL8: 0x6 (not DDR2-1066),  0x7 (DDR2-1066)  - BL4: 0x4 (not DDR2-1066),  0x5 (DDR2-1066)  DDR3:  - BL8 - 0x6  DDR4:  - BL8: 5 + RD_PREAMBLE     RD_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)   LPDDR3:  - BL8:  5 + RU(tDQSCK(max)/tCK) - RD(tDQSCK(min)/tCK) + RU(tODTon(max)/tCK) Programming Mode: Quasi-dynamic Group 1 and Group 4

| RD_ODT_DELAY

 2+| Indicates the delay, in DFI PHY clock cycles, from issuing a read command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2. Recommended values: DDR2:  - CL + AL - 4 (not DDR2-1066), CL + AL - 5 (DDR2-1066)    If (CL + AL - 4 &lt; 0), uMCTL2 does not support ODT for read operation. DDR3:  - CL - CWL DDR4:  - CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)    WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble) RD_PREAMBLE = 1 (1tCK read preamble), 2 (2tCK read preamble) If (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) &lt; 0, uMCTL2 does not support ODT for read operation. LPDDR3:  - RL + RD(tDQSCK(min)/tCK) - 1 - RU(tODTon(max)/tCK) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4 |  The delay, in DFI PHY clock cycles, from issuing a read command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2.  Recommended values:   DDR2:  - CL + AL - 4 (not DDR2-1066),  CL + AL - 5 (DDR2-1066)     If (CL + AL - 4 &lt; 0),  uMCTL2 does not support ODT for read operation.   DDR3:  - CL - CWL  DDR4:  - CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)     WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)     RD_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)     If (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) &lt; 0,  uMCTL2 does not support ODT for read operation.   LPDDR3:  - RL + RD(tDQSCK(min)/tCK) - 1 - RU(tODTon(max)/tCK) Programming Mode: Quasi-dynamic Group 1 and Group 4

|===


=== PCCFG fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| BL_EXP_MODE

 | Burst length expansion mode. By default (that is, bl_exp_mode==0) XPI expands every AXI burst into multiple HIF commands, using the memory burst length as a unit. If set to 1, then XPI uses half of the memory burst length as a unit. This applies to both reads and writes. When MSTR.data_bus_width==00, setting bl_exp_mode to 1 has no effect. This can be used in order to avoid or minimize t_ccd_l penalty in DDR4 and t_ccd_mw penalty in LPDDR4. Hence, bl_exp_mode=1 is only recommended if DDR4 or LPDDR4. Note that if DBICTL.dm_en=0, functionality is not supported in the following cases:  - MSTR.data_bus_width=01, MEMC_BURST_LENGTH=8 and MSTR.burst_rdwr=1000 (LPDDR4 only)  - MSTR.data_bus_width=01, MEMC_BURST_LENGTH=4 and MSTR.burst_rdwr=0100 (DDR4 only), with either MSTR.burstchop=0 or CRCPARCTL1.crc_enable=1 Functionality is also not supported if Data Channel Interleave is enabled. Programming Mode: Static | Burst length expansion mode. This applies to both reads and writes. When MSTR.data_bus_width==00, setting bl_exp_mode to 1 has no effect. This can be used in order to avoid or minimize t_ccd_l penalty in DDR4 and t_ccd_mw penalty in LPDDR4. Hence, bl_exp_mode=1 is only recommended if DDR4 or LPDDR4. Note that if DBICTL.dm_en=0, functionality is not supported in the following cases:  - MSTR.data_bus_width=01, MEMC_BURST_LENGTH=8 and MSTR.burst_rdwr=1000 (LPDDR4 only)  - MSTR.data_bus_width=01, MEMC_BURST_LENGTH=4 and MSTR.burst_rdwr=0100 (DDR4 only), with either MSTR.burstchop=0 or CRCPARCTL1.crc_enable=1 Functionality is also not supported if Data Channel Interleave is enabled. Programming Mode: Static | Burst length expansion mode. By default (i.e. bl_exp_mode==0) XPI expands every AXI burst into multiple HIF commands, using the memory burst length as a unit. If set to 1, then XPI will use half of the memory burst length as a unit.      This applies to both reads and writes. When MSTR.data_bus_width==00, setting bl_exp_mode to 1 has no effect.      This can be used in cases where Partial Writes is enabled (UMCTL2_PARTIAL_WR=1), in order to avoid or minimize t_ccd_l penalty in DDR4 and t_ccd_mw penalty in LPDDR4. Hence, bl_exp_mode=1 is only recommended if DDR4 or LPDDR4.      Note that if DBICTL.dm_en=0, functionality is not supported in the following cases:     - UMCTL2_PARTIAL_WR=0     - UMCTL2_PARTIAL_WR=1, MSTR.data_bus_width=01, MEMC_BURST_LENGTH=8 and MSTR.burst_rdwr=1000 (LPDDR4 only)     - UMCTL2_PARTIAL_WR=1, MSTR.data_bus_width=01, MEMC_BURST_LENGTH=4 and MSTR.burst_rdwr=0100 (DDR4 only), with either MSTR.burstchop=0 or CRCPARCTL1.crc_enable=1      Functionality is also not supported if Data Channel Interleave is enabled Programming Mode: Static

| PAGEMATCH_LIMIT

 | Page match four limit. If set to 1, limits the number of consecutive same page DDRC transactions that can be granted by the Port Arbiter to four when Page Match feature is enabled. If set to 0, there is no limit imposed on number of consecutive same page DDRC transactions. Programming Mode: Static | Page match four limit. Programming Mode: Static | Page match four limit. If set to 1, limits the number of consecutive same page DDRC transactions that can be granted by the Port Arbiter to four when Page Match feature is enabled.       If set to 0, there is no limit imposed on number of consecutive same page DDRC transactions. Programming Mode: Static

| GO2CRITICAL_EN

 | If set to 1 (enabled), sets co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals going to DDRC based on urgent input (awurgent, arurgent) coming from AXI master. If set to 0 (disabled), co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals at DDRC are driven to 1b'0. For uPCTL2, this register field must be set to 0. Programming Mode: Static | If enabled, sets co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals going to DDRC based on urgent input (awurgent, arurgent) coming from AXI master. If disabled, co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals at DDRC are driven to 1b'0. For uPCTL2, this register field must be set to 0. Programming Mode: Static | If set to 1 (enabled), sets co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals going to DDRC based on     urgent input (awurgent, arurgent) coming from AXI master. If set to 0 (disabled), co_gs_go2critical_wr and     co_gs_go2critical_lpr/co_gs_go2critical_hpr signals at DDRC are driven to 1b'0. Programming Mode: Static

|===


=== PGCR2 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DYNACPDD

 | Dynamic AC Power Down Driver: Powers down, when set, the output driver on I/O for ADDR and BA. This bit is ORed with bit ACIOCR[3] (ACPDD). 2+| 

| LPMSTRC0

 | Low-Power Master Channel 0: set to 1 to have channel 0 act as master to drive channel 1 low-power functions simultaneously. Only valid in shared-AC mode. 2+| 

| ACPDDC

 | AC Power-Down with Dual Channels : Set to 1 to power-down address/command lane when both data channels are powered-down. Only valid in shared-AC mode. 2+| 

| SHRAC

 | Shared-AC mode: set to 1 to enable shared address/command mode with two independent data channels - available only if shared address/command mode support is compiled in. 2+| 

| DTPMXTMR

 | Data Training PUB Mode Timer Exit: Specifies the number of controller clocks to wait when entering and exiting pub mode data training. The default value ensures controller refreshes do not cause memory model errors when entering and exiting data training. The value should be increased if controller initiated SDRAM ZQ short or long operation may occur just before or just after the execution of data training. 2+| Data Training PUB Mode Exit Timer.

| FXDLAT

 | Fixed Latency: Specified whether all reads should be returned to the controller with a fixed read latency. Enabling fixed read latency increases the read latency. Valid values are: 0 = Disable fixed read latency 1 = Enable fixed read latency Fixed read latency is calculated as (12 + (maximum DXnGTR.RxDGSL)/2) HDR clock cycles 2+| Fixed Latency.

| NOBUB

 | No Bubbles: Specified whether reads should be returned to the controller with no bubbles. Enabling no-bubble reads increases the read latency. Valid values are: 0 = Bubbles are allowed during reads 1 = Bubbles are not allowed during reads 2+| 

| TREFPRD

 | Refresh Period: Indicates the period in clock cycles after which the PUB has to issue a refresh command to the SDRAM. This is derived from the maximum refresh interval from the datasheet, tRFC(max) or REFI, divided by the clock cycle time. A further 400 clocks must be subtracted from the derived number to account for command flow and missed slots of refreshes in the internal PUB blocks. The default corresponds to DDR3 9*7.8us at 1066MHz when a burst of 9 refreshes are issued at every refresh interval. 2+| Refresh Period.

| CSNCIDMUX

 |  2+| CSN and CID Multiplexing.

| FXDLATINCR

 |  2+| Fixed Latency Programmable Increment.

| RFSHMODE

 |  2+| Refresh Mode.

| RESERVED_31

 |  2+| Reserved for future use.

|===


=== PTR0 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TPLLPD

 | PLL Power-Down Time: Number of configuration or APB clock cycles that the PLL must remain in power-down mode, i.e. number of clock cycles from when PLL power-down pin is asserted to when PLL power-down pin is deasserted. This must correspond to a value that is equal to or more than 1us. Default value corresponds to 1us. 2+| PLL Power-Down Time.

| TPLLGS

 | PLL Gear Shift Time: Number of configuration or APB clock cycles from when the PLL reset pin is deasserted to when the PLL gear shift pin is deasserted. This must correspond to a value that is equal to or more than 4us. Default value corresponds to 4us. 2+| PLL Gear Shift Time.

| TPHYRST

 | PHY Reset Time: Number of configuration or APB clock cycles that the PHY reset must remain asserted after PHY calibration is done before the reset to the PHY is deasserted. This is used to extend the reset to the PHY so that the reset is asserted for some clock cycles after the clocks are stable. Valid values are from 1 to 63 (the value must be non-zero). 2+| PHY Reset Time.

|===


=== PTR1 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TPLLLOCK

 | PLL Lock Time: Number of configuration or APB clock cycles for the PLL to stabilize and lock, i.e. number of clock cycles from when the PLL reset pin is deasserted to when the PLL has lock and is ready for use. This must correspond to a value that is equal to or more than 100us. Default value corresponds to 100us. 2+| PLL Lock Time.

| TPLLRST

 | PLL Reset Time: Number of configuration or APB clock cycles that the PLL must remain in reset mode, i.e. number of clock cycles from when PLL power-down pin is deasserted and PLL reset pin is asserted to when PLL reset pin is deasserted. The setting must correspond to a value that is equal to, or greater than, 3us. 2+| PLL Reset Time.

| RESERVED_14_13

 |  2+| Reserved for future use.

|===


=== PTR2 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TWLDLYS

 | Write Leveling Delay Settling Time: Number of controller clock cycles from when a new value of the write leveling delay is applies to the LCDL to when to DQS high is driven high. This allows the delay to settle. 2+| Write Leveling Delay Settling Time.

| TCALH

 | Calibration Hold Time: Number of controller clock cycles from when the clock was disabled (cal_clk_en deasserted) to when calibration is enable (cal_en asserted). 2+| Calibration Hold Time.

| TCALS

 | Calibration Setup Time: Number of controller clock cycles from when calibration is enabled (cal_en asserted) to when the calibration clock is asserted again (cal_clk_en asserted). 2+| Calibration Setup Time.

| TCALON

 | Calibration On Time: Number of clock cycles that the calibration clock is enabled (cal_clk_en asserted). 2+| Calibration On Time.

| RESERVED_31_20

 |  2+| Reserved for future use.

|===


=== PTR3 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TDINIT1

 | DRAM Initialization Time 1: DRAM initialization time in DRAM clock cycles corresponding to the following: DDR3 = CKE high time to first command (tRFC + 10 ns or 5 tCK, whichever is bigger) DDR2 = CKE high time to first command (400 ns) Default value corresponds to DDR3 tRFC of 360ns at 1066 MHz. 2+| DRAM Initialization Time 1.

| TDINIT0

 | DRAM Initialization Time 0: DRAM initialization time in DRAM clock cycles corresponding to the following: DDR3 = CKE low time with power and clock stable (500 us) DDR2 = CKE low time with power and clock stable (200 us) Default value corresponds to DDR3 500 us at 1066 MHz. During Verilog simulations, it is recommended that this value is changed to a much smaller value in order to avoid long simulation times. However, this may cause a memory model error, due to a violation of the CKE setup sequence. This violation is expected if this value is not programmed to the required SDRAM CKE low time, but memory models should be able to tolerate this violation without malfunction of the model. 2+| DRAM Initialization Time 0.

| RESERVED_31_30

 |  2+| Reserved for future use.

|===


=== PTR4 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| TDINIT3

 | DRAM Initialization Time 3: DRAM initialization time in DRAM clock cycles corresponding to the following: DDR3 = Time from ZQ initialization command to first command (1 us) Default value corresponds to the DDR3 640ns at 1066 MHz. 2+| DRAM Initialization Time 3.

| TDINIT2

 | DRAM Initialization Time 2: DRAM initialization time in DRAM clock cycles corresponding to the following: DDR3 = Reset low time (200 us on power-up or 100 ns after power-up) Default value corresponds to DDR3 200 us at 1066 MHz. 2+| DRAM Initialization Time 2.

| RESERVED_31_29

 |  2+| Reserved for future use.

|===


=== PWRCTL fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| DIS_CAM_DRAIN_SELFREF

 | Indicates whether skipping CAM draining is allowed when entering self-refresh. This register field cannot be modified while PWRCTL.selfref_sw == 1.  - 0 - CAMs must be empty before entering SR  - 1 - CAMs are not emptied before entering SR (unsupported)   Note, PWRCTL.dis_cam_drain_selfref=1 is unsupported in this release. PWRCTL.dis_cam_drain_selfref=0 is required.  Programming Mode: Dynamic | Indicates whether skipping CAM draining is allowed when entering self-refresh. This register field cannot be modified while PWRCTL.selfref_sw == 1.    Note, PWRCTL.dis_cam_drain_selfref=1 is unsupported in this release. PWRCTL.dis_cam_drain_selfref=0 is required.  Programming Mode: Dynamic | Indicates whether skipping CAM draining is allowed when entering Self-Refresh. This register field cannot be modified while PWRCTL.selfref_sw==1.   - 0 - CAMs must be empty before entering SR   - 1 - CAMs are not emptied before entering SR  Programming Mode: Dynamic

| SELFREF_SW

 | A value of 1 to this register causes system to move to self-refresh state immediately, as long as it is not in INIT or DPD/MPSM operating_mode. This is referred to as Software Entry/Exit to self-refresh.  - 1 - Software Entry to self-refresh  - 0 - Software Exit from self-refresh  Programming Mode: Dynamic | A value of 1 to this register causes system to move to self-refresh state immediately, as long as it is not in INIT or DPD/MPSM operating_mode. This is referred to as Software Entry/Exit to self-refresh.  Programming Mode: Dynamic | A value of 1 to this register causes system to move to Self Refresh state immediately, as long as it is not in INIT or DPD/MPSM operating_mode. This is referred to as Software Entry/Exit to Self Refresh.   - 1 - Software Entry to Self Refresh   - 0 - Software Exit from Self Refresh  Programming Mode: Dynamic

| EN_DFI_DRAM_CLK_DISABLE

 | Enables the assertion of dfi_dram_clk_disable whenever a clock is not required by the SDRAM. If set to 0, dfi_dram_clk_disable is never asserted. Assertion of dfi_dram_clk_disable is as follows: In DDR2/DDR3, can only be asserted in self-refresh. In DDR4, can be asserted in following:  - In Self-refresh  - In Maximum Power Saving Mode In mDDR/LPDDR2/LPDDR3, can be asserted in following:  - In Self-refresh  - In Power Down  - In Deep Power Down  - During Normal operation (Clock Stop) In LPDDR4, can be asserted in following:  - In Self-refresh Power Down  - In Power Down  - During Normal operation (Clock Stop)  Programming Mode: Dynamic | Enables the assertion of dfi_dram_clk_disable whenever a clock is not required by the SDRAM. Assertion of dfi_dram_clk_disable is as follows: In DDR2/DDR3, can only be asserted in self-refresh. In DDR4, can be asserted in following:  - In Self-refresh  - In Maximum Power Saving Mode In mDDR/LPDDR2/LPDDR3, can be asserted in following:  - In Self-refresh  - In Power Down  - In Deep Power Down  - During Normal operation (Clock Stop) In LPDDR4, can be asserted in following:  - In Self-refresh Power Down  - In Power Down  - During Normal operation (Clock Stop)  Programming Mode: Dynamic | Enable the assertion of dfi_dram_clk_disable whenever a clock is not required by the SDRAM.  If set to 0, dfi_dram_clk_disable is never asserted.  Assertion of dfi_dram_clk_disable is as follows:  In DDR2/DDR3, can only be asserted in Self Refresh.  In DDR4, can be asserted in following:   - in Self Refresh.   - in Maximum Power Saving Mode In mDDR/LPDDR2/LPDDR3, can be asserted in following:   - in Self Refresh   - in Power Down   - in Deep Power Down   - during Normal operation (Clock Stop) In LPDDR4, can be asserted in following:   - in Self Refresh Power Down   - in Power Down   - during Normal operation (Clock Stop)  Programming Mode: Dynamic

| POWERDOWN_EN

 | If true then the uMCTL2 goes into power-down after a programmable number of cycles "maximum idle clocks before power down" (PWRTMG.powerdown_to_x32). This register bit may be re-programmed during the course of normal operation. Programming Mode: Dynamic | Sets Power-down mode. This register bit may be re-programmed during the course of normal operation. Programming Mode: Dynamic | If true then the uMCTL2 goes into power-down after a programmable number of cycles "maximum idle clocks before power down" (PWRTMG.powerdown_to_x32). This register bit may be re-programmed during the course of normal operation. Programming Mode: Dynamic

| SELFREF_EN

 | If true then the uMCTL2 puts the SDRAM into self-refresh after a programmable number of cycles "maximum idle clocks before self-refresh (PWRTMG.selfref_to_x32)". This register bit may be re-programmed during the course of normal operation. Programming Mode: Dynamic | Sets Self-refresh. This register bit may be re-programmed during the course of normal operation. Programming Mode: Dynamic | If true then the uMCTL2 puts the SDRAM into Self Refresh after a programmable number of cycles "maximum idle clocks before Self Refresh (PWRTMG.selfref_to_x32)". This register bit may be re-programmed during the course of normal operation. Programming Mode: Dynamic

| MPSM_EN

 |  | Sets Maximum powersaving mode. Present only in designs configured to support DDR4. For non-DDR4, this register must not be set to 1. Note that MPSM is not supported when using a Synopsys DWC DDR PHY, if the PHY parameter DWC_AC_CS_USE is disabled, as the MPSM exit sequence requires the chip-select signal to toggle. FOR PERFORMANCE ONLY. Programming Mode: Dynamic | When this is 1, the uMCTL2 puts the SDRAM into maximum power saving mode when the transaction store is empty. This register must be reset to '0' to bring uMCTL2 out of maximum power saving mode. Present only in designs configured to support DDR4. For non-DDR4, this register should not be set to 1. Note that MPSM is not supported when using a Synopsys DWC DDR PHY, if the PHY parameter DWC_AC_CS_USE is disabled, as the MPSM exit sequence requires the chip-select signal to toggle. FOR PERFORMANCE ONLY. Programming Mode: Dynamic

| DEEPPOWERDOWN_EN

 2+|  | When this is 1, uMCTL2 puts the SDRAM into deep power-down mode when the transaction store is empty. This register must be reset to '0' to bring uMCTL2 out of deep power-down mode. Controller performs automatic SDRAM initialization on deep power-down exit. Present only in designs configured to support mDDR or LPDDR2 or LPDDR3. For non-mDDR/non-LPDDR2/non-LPDDR3, this register should not be set to 1. FOR PERFORMANCE ONLY. Programming Mode: Dynamic

|===


=== RFSHCTL0 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| REFRESH_MARGIN

 2+| Threshold value in number of DFI clock cycles before the critical refresh or page timer expires. A critical refresh is to be issued before this threshold is reached. It is recommended that this not be changed from the default value, currently shown as 0x2. It must always be less than internally used t_rfc_nom/32. Note that internally used t_rfc_nom is equal to RFSHTMG.t_rfc_nom_x1_x32 * 32 if RFSHTMG.t_rfc_nom_x1_sel=0. If RFSHTMG.t_rfc_nom_x1_sel=1 (for LPDDR2/LPDDR3/LPDDR4 per-bank refresh only), internally used t_rfc_nom is equal to RFSHTMG.t_rfc_nom_x1_x32. Note that, in LPDDR2/LPDDR3/LPDDR4, internally used t_rfc_nom may be divided by four if derating is enabled (DERATEEN.derate_enable=1). Unit: Multiples of 32 DFI clock cycles. Programming Mode: Dynamic - Refresh Related | Threshold value in number of DFI clock cycles before the critical refresh or page timer expires. A critical refresh is to be issued before this threshold is reached. It is recommended that this not be changed from the default value, currently shown as 0x2. It must always be less than internally used t_rfc_nom_x32. Note that, in LPDDR2/LPDDR3/LPDDR4, internally used t_rfc_nom_x32 may be equal to RFSHTMG.t_rfc_nom_x32&gt;&gt;2 if derating is enabled (DERATEEN.derate_enable=1). Otherwise, internally used t_rfc_nom_x32 will be equal to RFSHTMG.t_rfc_nom_x32.  Unit: Multiples of 32 DFI clocks. Programming Mode: Dynamic - Refresh Related

| REFRESH_TO_X1_X32

 2+| If the refresh timer (tRFCnom, also known as tREFI) has expired at least once, then a speculative refresh may be performed. A speculative refresh is a refresh performed at a time when refresh would be useful. When the SDRAM bus is idle for a period of time determined by this RFSHCTL0.refresh_to_x1_x32 and the refresh timer has expired at least once since the last refresh, then a speculative refresh is performed. Speculative refreshes continues successively until there are no refreshes pending or until new reads or writes are issued to the uMCTL2. FOR PERFORMANCE ONLY. Unit: DFI clock cycles or multiples of 32 DFI clock cycles, depending on RFSHTMG.t_rfc_nom_x1_sel. For more information on how to program this register field, see "Note 1" in the "Notes on Timing Registers" section. Programming Mode: Dynamic - Refresh Related | 

| REFRESH_BURST

 | The programmed value + 1 is the number of refresh timeouts that is allowed to accumulate before traffic is blocked and the refreshes are forced to execute. Closing pages to perform a refresh is a one-time penalty that must be paid for each group of refreshes. Therefore, performing refreshes in a burst reduces the per-refresh penalty of these page closings. Higher numbers for RFSHCTL.refresh_burst slightly increases utilization; lower numbers decreases the worst-case latency associated with refreshes.  - 0 - Single refresh  - 1 - Burst-of-2 refresh  - 7 - Burst-of-8 refresh For more information on burst refresh feature, see section 3.9 of DDR2 JEDEC specification - JESD79-2F.pdf. For DDR2/3, the refresh is always per-rank and not per-bank. The rank refresh can be accumulated over 8*tREFI cycles using the burst refresh feature. In DDR4 mode, according to Fine Granularity feature, 8 refreshes can be postponed in 1X mode, 16 refreshes in 2X mode and 32 refreshes in 4X mode. If using PHY-initiated updates, care must be taken in the setting of RFSHCTL0.refresh_burst, to ensure that tRFCmax is not violated due to a PHY-initiated update occurring shortly before a refresh burst is due. In this situation, the refresh burst is delayed until the PHY-initiated update is complete. In per-bank refresh mode of LPDDR2/LPDDR3/LPDDR4 (RFSHCTL0.per_bank_refresh = 1), 64 refreshes can be postponed. Programming Mode: Dynamic - Refresh Related | The programmed value + 1 is the number of refresh timeouts that is allowed to accumulate before traffic is blocked and the refreshes are forced to execute. Closing pages to perform a refresh is a one-time penalty that must be paid for each group of refreshes. Therefore, performing refreshes in a burst reduces the per-refresh penalty of these page closings. Higher numbers for RFSHCTL.refresh_burst slightly increases utilization; lower numbers decreases the worst-case latency associated with refreshes.  - 0 - Single refresh  - 1 - Burst-of-2 refresh  - 7 - Burst-of-8 refresh For more information on burst refresh feature, see section 3.9 of DDR2 JEDEC specification - JESD79-2F.pdf. For DDR2/3, the refresh is always per-rank and not per-bank. The rank refresh can be accumulated over 8*tREFI cycles using the burst refresh feature. In DDR4 mode, according to Fine Granularity feature, 8 refreshes can be postponed in 1X mode, 16 refreshes in 2X mode and 32 refreshes in 4X mode. If using PHY-initiated updates, care must be taken in the setting of RFSHCTL0.refresh_burst, to ensure that tRFCmax is not violated due to a PHY-initiated update occurring shortly before a refresh burst is due. In this situation, the refresh burst is delayed until the PHY-initiated update is complete. In per-bank refresh mode of LPDDR2/LPDDR3/LPDDR4 (RFSHCTL0.per_bank_refresh = 1), 64 refreshes can be postponed. In LPDDR4 mode, if per-bank refresh is enabled (RFSHCTL0.per_bank_refresh = 1), and automatic switching from per-bank to all-bank refresh is enabled (RFSHCTL0.auto_refab_en = 2'b01 or RFSHCTL0.auto_refab_en = 2'b10), the uCMTL2 divides this value by 8 when it switches automatically from per-bank to all-bank refresh. Programming Mode: Dynamic - Refresh Related | The programmed value + 1 is the number of refresh timeouts that is allowed to accumulate before traffic is blocked and the refreshes are forced to execute. Closing pages to perform a refresh is a one-time penalty that must be paid for each group of refreshes. Therefore, performing refreshes in a burst reduces the per-refresh penalty of these page closings. Higher numbers for RFSHCTL.refresh_burst slightly increases utilization; lower numbers decreases the worst-case latency associated with refreshes.  - 0 - single refresh  - 1 - burst-of-2 refresh  - 7 - burst-of-8 refresh For information on burst refresh feature refer to section 3.9 of DDR2 JEDEC specification - JESD79-2F.pdf. For DDR2/3, the refresh is always per-rank and not per-bank. The rank refresh can be accumulated over 8*tREFI cycles using the burst refresh feature. In DDR4 mode, according to Fine Granularity feature, 8 refreshes can be postponed in 1X mode, 16 refreshes in 2X mode and 32 refreshes in 4X mode. If using PHY-initiated updates, care must be taken in the setting of RFSHCTL0.refresh_burst, to ensure that tRFCmax is not violated due to a PHY-initiated update occurring shortly before a refresh burst was due. In this situation, the refresh burst will be delayed until the PHY-initiated update is complete. Programming Mode: Dynamic - Refresh Related

| PER_BANK_REFRESH

 2+|  |   - 1 - Per bank refresh;  - 0 - All bank refresh. Per bank refresh allows traffic to flow to other banks. Per bank refresh is not supported by all LPDDR2 devices but should be supported by all LPDDR3/LPDDR4 devices. Present only in designs configured to support LPDDR2/LPDDR3/LPDDR4 Programming Mode: Static

| REFRESH_TO_X32

 2+|  | If the refresh timer (tRFCnom, also known as tREFI) has expired at least once, but it has not expired (RFSHCTL0.refresh_burst+1) times yet, then a speculative refresh may be performed. A speculative refresh is a refresh performed at a time when refresh would be useful, but before it is absolutely required. When the SDRAM bus is idle for a period of time determined by this RFSHCTL0.refresh_to_x32 and the refresh timer has expired at least once since the last refresh, then a speculative refresh is performed. Speculative refreshes continues successively until there are no refreshes pending or until new reads or writes are issued to the uMCTL2. FOR PERFORMANCE ONLY.  Unit: Multiples of 32 DFI clocks. Programming Mode: Dynamic - Refresh Related

|===


=== RFSHCTL3 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| REFRESH_UPDATE_LEVEL

 2+| Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the refresh registers have been updated. refresh_update_level must not be toggled when the DDRC is in reset (core_ddrc_rstn = 0). The refresh registers are automatically updated when exiting reset. Programming Mode: Dynamic | Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the refresh register(s) have been updated. refresh_update_level must not be toggled when the DDRC is in reset (core_ddrc_rstn = 0). The refresh register(s) are automatically updated when exiting reset. Programming Mode: Dynamic

| DIS_AUTO_REFRESH

 | When '1', disable auto-refresh generated by the uMCTL2. When auto-refresh is disabled, the SoC must generate refreshes using the registers DBGCMD.rankn_refresh. When dis_auto_refresh transitions from 0 to 1, any pending refreshes are immediately scheduled by the uMCTL2. If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), disable auto-refresh is not supported, and this bit must be set to '0'. (DDR4 only) If FGR mode is enabled (RFSHCTL3.refresh_mode &gt; 0), disable auto-refresh is not supported, and this bit must be set to '0'. This register field is changeable on the fly. Programming Mode: Dynamic - Refresh Related | Disables auto-refresh generated by the uMCTL2. When auto-refresh is disabled, the SoC must generate refreshes using the registers DBGCMD.rankn_refresh. When dis_auto_refresh transitions from 0 to 1, any pending refreshes are immediately scheduled by the uMCTL2. If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), disable auto-refresh is not supported, and this bit must be set to '0'. (DDR4 only) If FGR mode is enabled (RFSHCTL3.refresh_mode &gt; 0), disable auto-refresh is not supported, and this bit must be set to '0'. This register field is changeable on the fly. Programming Mode: Dynamic - Refresh Related | When '1', disable auto-refresh generated by the uMCTL2. When auto-refresh is disabled, the SoC core must generate refreshes using the registers DBGCMD.rankn_refresh. When dis_auto_refresh transitions from 0 to 1, any pending refreshes are immediately scheduled by the uMCTL2. If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), disable auto-refresh is not supported, and this bit must be set to '0'. (DDR4 only) If FGR mode is enabled (RFSHCTL3.refresh_mode &gt; 0), disable auto-refresh is not supported, and this bit must be set to '0'. This register field is changeable on the fly. Programming Mode: Dynamic - Refresh Related

| REFRESH_MODE

 |  | Indicates fine granularity refresh mode. Everything not described in "Values" section is reserved.  Note:   - Only Fixed 1x mode is supported if RFSHCTL3.dis_auto_refresh = 1  - The on-the-fly modes are not supported in this version of the uMCTL2  - This must be set up while the controller is in reset or while the controller is in self-refresh mode. Changing this during normal operation is not allowed. Making this a dynamic register is supported in future version of the uMCTL2  - This register field has effect only if a DDR4 SDRAM device is in use (MSTR.ddr4 = 1) Programming Mode: Quasi-dynamic Group 2 | Fine Granularity Refresh Mode   - 000 - Fixed 1x (Normal mode)   - 001 - Fixed 2x   - 010 - Fixed 4x   - 101 - Enable on the fly 2x (not supported)   - 110 - Enable on the fly 4x (not supported)   - Everything else - reserved Note: Only Fixed 1x mode is supported if RFSHCTL3.dis_auto_refresh = 1. Note: The on-the-fly modes are not supported in this version of the uMCTL2. Note: This must be set up while the Controller is in reset or while the Controller is in self-refresh mode. Changing this during normal operation is not allowed. Making this a dynamic register will be supported in future version of the uMCTL2. Note: This register field has effect only if a DDR4 SDRAM device is in use (MSTR.ddr4 = 1). Programming Mode: Quasi-dynamic Group 2

|===


=== RFSHTMG fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| T_RFC_NOM_X1_X32

 2+| Average time interval between refreshes per rank (Specification: 7.8us for DDR2, DDR3 and DDR4. See JEDEC specification for mDDR, LPDDR2, LPDDR3 and LPDDR4). When the controller is operating in 1:1 mode, set this register to RoundDown(tREFI/tCK) When the controller is operating in 1:2 mode, set this register to RoundDown(RoundDown(tREFI/tCK)/2) In both the previous cases, if RFSHTMG.t_rfc_nom_x1_sel = 0, divide the previous result by 32 and round down. For LPDDR2/LPDDR3/LPDDR4:  - If using all-bank refreshes (RFSHCTL0.per_bank_refresh = 0), use tREFIab in the previous calculations  - If using per-bank refreshes (RFSHCTL0.per_bank_refresh = 1), use tREFIpb in the previous calculations For DDR4 mode, tREFI value is different depending on the refresh mode. You must program appropriate value from the spec based on the value programmed in the refresh mode register. Note:  - RFSHTMG.t_rfc_nom_x1_x32 must be greater than 0x1  - If RFSHTMG.t_rfc_nom_x1_sel == 1, RFSHTMG.t_rfc_nom_x1_x32 must be greater than RFSHTMG.t_rfc_min  - If RFSHTMG.t_rfc_nom_x1_sel == 0, RFSHTMG.t_rfc_nom_x1_x32 * 32 must be greater than RFSHTMG.t_rfc_min  - In non-DDR4 or DDR4 Fixed 1x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0xFFE  - In DDR4 Fixed 2x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0x7FF  - In DDR4 Fixed 4x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0x3FF Unit: DFI clock cycles or multiples of 32 DFI clock cycles, depending on RFSHTMG.t_rfc_nom_x1_sel. For more information on how to program this register field, see "Note 1" in the "Notes on Timing Registers" section. Programming Mode: Dynamic - Refresh Related | 

| T_RFC_MIN

 2+| tRFC (min): Minimum time from refresh to refresh or activate. When the controller is operating in 1:1 mode, t_rfc_min must be set to RoundUp(tRFCmin/tCK). When the controller is operating in 1:2 mode, t_rfc_min must be set to RoundUp(RoundUp(tRFCmin/tCK)/2). In LPDDR2/LPDDR3/LPDDR4 mode:  - If using all-bank refreshes, the tRFCmin value in the previous equations is equal to tRFCab  - If using per-bank refreshes, the tRFCmin value in the previous equations is equal to tRFCpb In DDR4 mode, the tRFCmin value in the previous equations is different depending on the refresh mode (fixed 1X,2X,4X) and the device density. You must program the appropriate value from the spec based on the 'refresh_mode' and the device density that is used. Unit: DFI clock cycles. Programming Mode: Dynamic - Refresh Related | tRFC (min): Minimum time from refresh to refresh or activate.  When the controller is operating in 1:1 mode, t_rfc_min should be set to RoundUp(tRFCmin/tCK).  When the controller is operating in 1:2 mode, t_rfc_min should be set to RoundUp(RoundUp(tRFCmin/tCK)/2).  In LPDDR2/LPDDR3/LPDDR4 mode:   - if using all-bank refreshes, the tRFCmin value in the above equations is equal to tRFCab   - if using per-bank refreshes, the tRFCmin value in the above equations is equal to tRFCpb In DDR4 mode, the tRFCmin value in the above equations is different depending on the refresh mode (fixed 1X,2X,4X) and the device density. The user should program the appropriate value from the spec based on the 'refresh_mode' and the device density that is used.  Unit: Clocks. Programming Mode: Dynamic - Refresh Related

| LPDDR3_TREFBW_EN

 2+|  | Used only when LPDDR3 memory type is connected. Should only be changed when uMCTL2 is in reset. Specifies whether to use the tREFBW parameter (required by some LPDDR3 devices which comply with earlier versions of the LPDDR3 JEDEC specification) or not:    - 0 - tREFBW parameter not used    - 1 - tREFBW parameter used Programming Mode: Static

| T_RFC_NOM_X32

 2+|  | tREFI: Average time interval between refreshes per rank (Specification: 7.8us for DDR2, DDR3 and DDR4. See JEDEC specification for mDDR, LPDDR2, LPDDR3 and LPDDR4). For LPDDR2/LPDDR3/LPDDR4:   - if using all-bank refreshes (RFSHCTL0.per_bank_refresh = 0), this register should be set to tREFIab   - if using per-bank refreshes (RFSHCTL0.per_bank_refresh = 1), this register should be set to tREFIpb When the controller is operating in 1:2 frequency ratio mode, program this to (tREFI/2), no rounding up.  In DDR4 mode, tREFI value is different depending on the refresh mode. The user should program the appropriate value from the spec based on the value programmed in the refresh mode register. Note that RFSHTMG.t_rfc_nom_x32 * 32 must be greater than RFSHTMG.t_rfc_min, and RFSHTMG.t_rfc_nom_x32 must be greater than 0x1.    - Non-DDR4 or DDR4 Fixed 1x mode: RFSHTMG.t_rfc_nom_x32 must be less than or equal to 0xFFE.   - DDR4 Fixed 2x mode: RFSHTMG.t_rfc_nom_x32 must be less than or equal to 0x7FF.   - DDR4 Fixed 4x mode: RFSHTMG.t_rfc_nom_x32 must be less than or equal to 0x3FF. Unit: Multiples of 32 clocks. Programming Mode: Dynamic - Refresh Related

|===


=== SBRCTL fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| SCRUB_INTERVAL

 2+| Scrub interval. (512 x scrub_interval) number of clock cycles between two scrub read commands. If set to 0, scrub commands are issued back-to-back. This mode of operation (scrub_interval=0) can typically be used for scrubbing the full range of memory at once before or after SW controlled low power operations. After completing the full range of scrub while scrub_interval=0, scrub_done register is set and sbr_done_intr interrupt signal is asserted. This mode can not be used with Inline ECC: If MEMC_INLINE_ECC is 1 and scrub_interval is programme to 0, then RMW logic inside scrubber is disabled. New programmed value takes effect only after scrubber is disabled by programming scrub_en to 0. Unit: Multiples of 512 sbr_clk cycles. Programming Mode: Dynamic | Scrub interval. (512 x scrub_interval) number of clock cycles between two scrub read commands. If set to 0, scrub commands are issued back-to-back. This mode of operation (scrub_interval=0) can typically be used for scrubbing the full range of memory at once before or after SW controlled low power operations. After completing the full range of scrub while scrub_interval=0, scrub_done register is set and sbr_done_intr interrupt signal is asserted.       This mode can't be used with Inline ECC: If MEMC_INLINE_ECC is 1 and scrub_interval is programme to 0, then RMW logic inside scrubber is disabled.      New programmed value will take effect only after scrubber is disabled by programming scrub_en to 0. Programming Mode: Dynamic

| SCRUB_BURST

 2+| Scrub burst count. Determines the number of back-to-back scrub read commands that can be issued together when the controller is in one of the HW controlled low power modes with Sideband ECC, both normal operation mode and low-power mode with Inline ECC. During these modes, the period of the scrub burst becomes "scrub_burst*scrub_interval" cycles. During normal operation mode of the controller with Sideband ECC (not in power-down or self-refresh), scrub_burst is ignored and only one scrub command is generated. Valid values are (Sideband ECC): 1: 1 read, 2: 4 reads, 3: 16 reads, 4: 64 reads, 5: 256 reads, 6: 1024 reads. (Inline ECC): 1: 8 reads, 2: 16 reads, 3: 32 reads. New programmed value takes effect only after scrubber is disabled by programming scrub_en to 0. Programming Mode: Dynamic | Scrub burst count. Determines the number of back-to-back scrub read commands that can be issued together      when the controller is in one of the HW controlled low power modes with Sideband ECC, both normal operation mode and low-power mode with Inline ECC. During these modes, the period of the scrub burst      becomes "scrub_burst*scrub_interval" cycles. During normal operation mode of the controller with Sideband ECC (not in power-down      or self refresh), scrub_burst is ignored and only one scrub command is generated.  Valid values are (Sideband ECC): 1: 1 read, 2: 4 reads, 3: 16 reads, 4: 64 reads, 5: 256 reads, 6: 1024 reads. (Inline ECC): 1: 8 reads, 2: 16 reads, 3: 32 reads.      New programmed value will take effect only after scrubber is disabled by programming scrub_en to 0. Programming Mode: Dynamic

| SCRUB_MODE

 |   - scrub_mode:0 ECC scrubber performs reads  - scrub_mode:1 ECC scrubber performs writes Programming Mode: Dynamic | Sets scrub_mode. Programming Mode: Dynamic | scrub_mode:0 ECC scrubber will perform reads   scrub_mode:1 ECC scrubber will perform writes Programming Mode: Dynamic

| SCRUB_DURING_LOWPOWER

 | Continue scrubbing during low power. If set to 1, burst of scrubs is issued in hardware controlled low power modes. There are two such modes: automatically initiated by idleness or initiated by Hardware low power interface. If set to 0, the scrubber does not attempt to send commands while the DDRC is in HW controlled low power modes. In this case, the scrubber remembers the last address issued and automatically continues from there when the DDRC exits the low power mode. Programming Mode: Dynamic | Continue scrubbing during low power. If enabled, burst of scrubs is issued in hardware controlled low power modes. There are two such modes: automatically initiated by idleness or initiated by Hardware low power interface. If disabled, the scrubber does not attempt to send commands while the DDRC is in HW controlled low power modes. In this case, the scrubber remembers the last address issued and automatically continues from there when the DDRC exits the low power mode. Programming Mode: Dynamic | Continue scrubbing during low power.  If set to 1, burst of scrubs will be issued in HW controlled low power modes. There are two such modes: automatically initiated by idleness or initiated by Hardware low power interface.  If set to 0, the scrubber will not attempt to send commands while the DDRC is in HW controlled low power modes. In this case, the scrubber will remember the last address issued and will automatically continue from there when the DDRC exits the LP mode. Programming Mode: Dynamic

| SCRUB_EN

 | Enables ECC scrubber.  If set to 1, enables the scrubber to generate background read commands after the memories are initialized. If set to 0, disables the scrubber, resets the address generator to 0 and clears the scrubber status. This bitfield must be accessed separately from the other bitfields in this register. Programming Mode: Dynamic | Enables ECC scrubber.  (Enabled)Enables the scrubber to generate background read commands after the memories are initialized. (Disabled)Disables the scrubber, resets the address generator to 0 and clears the scrubber status. This bitfield must be accessed separately from the other bitfields in this register. Programming Mode: Dynamic | Enable ECC scrubber.  If set to 1, enables the scrubber to generate background read commands after the memories are initialized.  If set to 0, disables the scrubber, resets the address generator to 0       and clears the scrubber status.  This bitfield must be accessed separately from the other bitfields in this register. Programming Mode: Dynamic

|===


=== SCHCR1 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| RESERVED_1_0

 |  2+| Reserved for future use.

| ALLRANK

 |  2+| All Ranks Enabled.

| RESERVED_3

 |  2+| Reserved for future use.

| SCBK

 |  2+| Scheduler Command Bank Address.

| SCBG

 |  2+| Scheduler Command Bank Group.

| SCADDR

 |  2+| Scheduler Command Address.

| SCRNK

 |  2+| Scheduler Rank Address.

|===


=== ZQ0CR0 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ZQ0_ZQPD

 | ZQ Power Down: Powers down, if set, the PZQ cell. 2+| 

| ZQ0_ZCALEN

 | Impedance Calibration Enable: Enables, if set, the impedance calibration of this ZQ control block when impedance calibration is triggered using either the ZCAL bit of PIR register or the DFI update interface. 2+| 

| ZQ0_ZCALBYP

 | Impedance Calibration Bypass: Bypasses, if set, impedance calibration of this ZQ control block when impedance calibration is already in progress. Impedance calibration can be disabled prior to trigger by using the ZCALEN bit. 2+| 

| ZQ0_ZDEN

 | Impedance Over-ride Enable: When this bit is set, it allows users to directly drive the impedance control using the data programmed in the ZDATA field. Otherwise, the control is generated automatically by the impedance control logic. 2+| 

| ZQ0_ZDATA

 | Impedance Over-Ride Data: Data used to directly drive the impedance control. ZDATA field mapping for D3F I/Os is as follows: ZDATA[27:21] is used to select the pull-up on-die termination impedance ZDATA[20:14] is used to select the pull-down on-die termination impedance ZDATA[13:7] is used to select the pull-up output impedance ZDATA[6:0] is used to select the pull-down output impedance ZDATA field mapping for D3A/B/R I/Os is as follows: ZDATA[27:20] is reserved and returns zeros on reads ZDATA[19:15] is used to select the pull-up on-die termination impedance ZDATA[14:10] is used to select the pull-down on-die termination impedance ZDATA[9:5] is used to select the pull-up output impedance ZDATA[4:0] is used to select the pull-down output impedance The default value is 0x000014A for I/O type D3C/R and 0x0001830 for I/O type D3F. 2+| 

|===


=== ZQ0CR1 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ZQ0_DFIPU1

 | DFI Update Interface 1: Sets this impedance controller to be enabled for calibration when the DFI PHY update interface 1 (channel 1) requests an update. Only valid in shared-AC mode. 2+| 

| ZQ0_DFIPU0

 | DFI Update Interface 0: Sets this impedance controller to be enabled for calibration when the DFI PHY update interface 0 (channel 0) requests an update. 2+| 

| ZQ0_DFICCU

 | DFI Concurrent Controller Update Interface: Sets this impedance controller to be enabled for calibration when both of the DFI controller update interfaces request an update on the same clock. This provides the ability to enable impedance calibration updates for the Address/Command lane. Only valid in shared-AC mode. 2+| 

| ZQ0_DFICU1

 | DFI Controller Update Interface 1: Sets this impedance controller to be enabled for calibration when the DFI controller update interface 1 (channel 1) requests an update. 2+| 

| ZQ0_DFICU0

 | DFI Controller Update Interface 0: Sets this impedance controller to be enabled for calibration when the DFI controller update interface 0 (channel 0) requests an update. 2+| 

| ZQ0_ZPROG

 | Impedance Divide Ratio: Selects the external resistor divide ratio to be used to set the output impedance and the on-die termination as follows: ZPROG[7:4] = On-die termination divide select ZPROG[3:0] = Output impedance divide select 2+| 

|===


=== ZQ0PR fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| RESERVED_7_0

 |  | Reserved for future use. | 

| ZPROG_ASYM_DRV_PU

 |  2+| Asymmetric Drive Pull-up Impedance Divide Ratio.

| ZPROG_ASYM_DRV_PD

 |  2+| Asymmetric Drive Pull-down Impedance Divide Ratio.

| ZPROG_PU_ODT_ONLY

 |  2+| ODT Pull-up Impedance Divide Ratio.

| PU_DRV_ADJUST

 |  2+| Pull-up Drive Strength Adjustment.

| PD_DRV_ADJUST

 |  2+| Pull-down Drive Strength Adjustment.

| RESERVED_27_24

 |  | Reserved for future use. | 

| PU_ODT_ONLY

 |  | Pull-up ODT Only Enable. | 

| ZSEGBYP

 |  | Impedance Calibration Segment Bypass. | 

| ODT_ZDEN

 |  | On-Die Termination Over-ride Enable. | 

| DRV_ZDEN

 |  | Output Impedance Over-Ride Enable. | 

| ZQDIV

 2+|  | Impedance Divide Ratio.

| ZCTRL_UPPER

 2+|  | ZCTRL Upper Bus.

| RESERVED_31_28

 2+|  | Reserved for future use.

|===


=== ZQ1CR0 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ZQ1_ZQPD

 | ZQ Power Down: Powers down, if set, the PZQ cell. 2+| 

| ZQ1_ZCALEN

 | Impedance Calibration Enable: Enables, if set, the impedance calibration of this ZQ control block when impedance calibration is triggered using either the ZCAL bit of PIR register or the DFI update interface. 2+| 

| ZQ1_ZCALBYP

 | Impedance Calibration Bypass: Bypasses, if set, impedance calibration of this ZQ control block when impedance calibration is already in progress. Impedance calibration can be disabled prior to trigger by using the ZCALEN bit. 2+| 

| ZQ1_ZDEN

 | Impedance Over-ride Enable: When this bit is set, it allows users to directly drive the impedance control using the data programmed in the ZDATA field. Otherwise, the control is generated automatically by the impedance control logic. 2+| 

| ZQ1_ZDATA

 | Impedance Over-Ride Data: Data used to directly drive the impedance control. ZDATA field mapping for D3F I/Os is as follows: ZDATA[27:21] is used to select the pull-up on-die termination impedance ZDATA[20:14] is used to select the pull-down on-die termination impedance ZDATA[13:7] is used to select the pull-up output impedance ZDATA[6:0] is used to select the pull-down output impedance ZDATA field mapping for D3A/B/R I/Os is as follows: ZDATA[27:20] is reserved and returns zeros on reads ZDATA[19:15] is used to select the pull-up on-die termination impedance ZDATA[14:10] is used to select the pull-down on-die termination impedance ZDATA[9:5] is used to select the pull-up output impedance ZDATA[4:0] is used to select the pull-down output impedance The default value is 0x000014A for I/O type D3C/R and 0x0001830 for I/O type D3F. 2+| 

|===


=== ZQ1CR1 fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| ZQ1_DFIPU1

 | DFI Update Interface 1: Sets this impedance controller to be enabled for calibration when the DFI PHY update interface 1 (channel 1) requests an update. Only valid in shared-AC mode. 2+| 

| ZQ1_DFIPU0

 | DFI Update Interface 0: Sets this impedance controller to be enabled for calibration when the DFI PHY update interface 0 (channel 0) requests an update. 2+| 

| ZQ1_DFICCU

 | DFI Concurrent Controller Update Interface: Sets this impedance controller to be enabled for calibration when both of the DFI controller update interfaces request an update on the same clock. This provides the ability to enable impedance calibration updates for the Address/Command lane. Only valid in shared-AC mode. 2+| 

| ZQ1_DFICU1

 | DFI Controller Update Interface 1: Sets this impedance controller to be enabled for calibration when the DFI controller update interface 1 (channel 1) requests an update. 2+| 

| ZQ1_DFICU0

 | DFI Controller Update Interface 0: Sets this impedance controller to be enabled for calibration when the DFI controller update interface 0 (channel 0) requests an update. 2+| 

| ZQ1_ZPROG

 | Impedance Divide Ratio: Selects the external resistor divide ratio to be used to set the output impedance and the on-die termination as follows: ZPROG[7:4] = On-die termination divide select ZPROG[3:0] = Output impedance divide select 2+| 

|===


=== ZQ1PR fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| RESERVED_7_0

 |  | Reserved for future use. | 

| ZPROG_ASYM_DRV_PU

 |  2+| Asymmetric Drive Pull-up Impedance Divide Ratio.

| ZPROG_ASYM_DRV_PD

 |  2+| Asymmetric Drive Pull-down Impedance Divide Ratio.

| ZPROG_PU_ODT_ONLY

 |  2+| ODT Pull-up Impedance Divide Ratio.

| PU_DRV_ADJUST

 |  2+| Pull-up Drive Strength Adjustment.

| PD_DRV_ADJUST

 |  2+| Pull-down Drive Strength Adjustment.

| RESERVED_27_24

 |  | Reserved for future use. | 

| PU_ODT_ONLY

 |  | Pull-up ODT Only Enable. | 

| ZSEGBYP

 |  | Impedance Calibration Segment Bypass. | 

| ODT_ZDEN

 |  | On-Die Termination Over-ride Enable. | 

| DRV_ZDEN

 |  | Output Impedance Over-Ride Enable. | 

| ZQDIV

 2+|  | Impedance Divide Ratio.

| ZCTRL_UPPER

 2+|  | ZCTRL Upper Bus.

| RESERVED_31_28

 2+|  | Reserved for future use.

|===


=== ZQ2PR fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| RESERVED_7_0

 |  | Reserved for future use. | 

| ZPROG_ASYM_DRV_PU

 |  2+| Asymmetric Drive Pull-up Impedance Divide Ratio.

| ZPROG_ASYM_DRV_PD

 |  2+| Asymmetric Drive Pull-down Impedance Divide Ratio.

| ZPROG_PU_ODT_ONLY

 |  2+| ODT Pull-up Impedance Divide Ratio.

| PU_DRV_ADJUST

 |  2+| Pull-up Drive Strength Adjustment.

| PD_DRV_ADJUST

 |  2+| Pull-down Drive Strength Adjustment.

| RESERVED_27_24

 |  | Reserved for future use. | 

| PU_ODT_ONLY

 |  | Pull-up ODT Only Enable. | 

| ZSEGBYP

 |  | Impedance Calibration Segment Bypass. | 

| ODT_ZDEN

 |  | On-Die Termination Over-ride Enable. | 

| DRV_ZDEN

 |  | Output Impedance Over-Ride Enable. | 

| ZQDIV

 2+|  | Impedance Divide Ratio.

| ZCTRL_UPPER

 2+|  | ZCTRL Upper Bus.

| RESERVED_31_28

 2+|  | Reserved for future use.

|===


=== ZQCR fields

[cols="1s,4,4,4"]
|===
| Field
^s| lan966x
^s| lan969x
^s| sparx5


| RESERVED_0

 |  2+| Reserved for future use.

| TERM_OFF

 |  2+| Termination OFF.

| ZQPD

 |  2+| ZQ Power Down.

| RESERVED_7_3

 |  2+| Reserved for future use.

| PGWAIT

 |  2+| Programmable Wait.

| ZCALT

 |  2+| Impedance Calibration Type.

| AVGMAX

 |  2+| Maximum Averaging Round.

| AVGEN

 |  2+| Averaging Algorithm Enable.

| IODLMT

 |  2+| IO VT Drift Limit.

| RESERVED_26_25

 |  | Reserved for future use. | 

| FORCE_ZCAL_VT_UPDATE

 |  2+| Force Impedance Calibration VT Update.

| RESERVED_31_28

 |  | Reserved for future use. | 

| ASYM_DRV_EN

 2+|  | Enable Asymmetric Drive Strength Enable.

| PU_ODT_ONLY

 2+|  | Pull-up ODT Only Enable.

| DIS_NON_LIN_COMP

 2+|  | Disable Non-linear Compensation Enable.

| ZCTRL_UPPER

 2+|  | ZCTRL Upper Bus.

|===

